#v4.2: update for TD serise implementations
#v5.0: align to env v5.0
#v5.1: support fraud

import numpy as np
import copy
from enum import IntEnum
import itertools

import deal_cards_5_2 as dc
from cards_env_5_2 import PokerEnvironment_6_1
from play_agent_proxy_5_2 import PlayAgentProxy
from play_guess_CNN_5_2 import PlayGuess_CNN
#import meas_5 as meas
import game_verify_online_5_2 as game_verify_on

####################################################
#  OFFLINE verification
#
####################################################

PRE_CHECK =True

class ErrorIDs(IntEnum):
    ERR_NONE    = 0
    ERR_N       = 1
    ERR_MISC    = 2

cards_7307 = np.array([ [0 ,  1,   1 ,  0 ,  1,   1,   0,   0],
                        [1 ,  1,   2 ,  0 ,  1,   4,   0,   0],
                        [2 ,  1,   3 ,  0 ,  1,   2,   0,   0],
                        [3 ,  1,   4 ,  0 ,  1,   1,   0,   0],
                        [4 ,  1,   5 ,  5 ,  1,   1,   0,   0],
                        [5 ,  1,   6 ,  0 ,  1,   4,   0,   0],
                        [6 ,  1,   7 ,  0 ,  1,   3,   0,   0],
                        [7 ,  1,   8 ,  0 ,  1,   2,   0,   0],
                        [8 ,  1,   9 ,  0 ,  1,   1,   0,   0],
                        [9 ,  1,   10,  10,  1,   4,   0,   0],
                        [10,  1,   11,  0 ,  1,   3,   0,   0],
                        [11,  1,   12,  0 ,  1,   2,   0,   0],
                        [12,  1,   13,  10,  1,   3,   0,   0],
                        [13,  2,   1 ,  0 ,  0,   3,   0,   0],
                        [14,  2,   2 ,  0 ,  1,   1,   0,   0],
                        [15,  2,   3 ,  0 ,  0,   4,   0,   0],
                        [16,  2,   4 ,  0 ,  0,   1,   0,   1],
                        [17,  2,   5 ,  5 ,  0,   1,   0,   1],
                        [18,  2,   6 ,  0 ,  0,   1,   0,   0],
                        [19,  2,   7 ,  0 ,  0,   3,   0,   0],
                        [20,  2,   8 ,  0 ,  0,   4,   0,   0],
                        [21,  2,   9 ,  0 ,  0,   1,   0,   0],
                        [22,  2,   10,  10,  0,   1,   0,   0],
                        [23,  2,   11,  0 ,  0,   1,   0,   0],
                        [24,  2,   12,  0 ,  0,   1,   0,   0],
                        [25,  2,   13,  10,  0,   3,   0,   0],
                        [26,  3,   1 ,  0 ,  0,   1,   0,   0],
                        [27,  3,   2 ,  0 ,  1,   2,   0,   0],
                        [28,  3,   3 ,  0 ,  0,   2,   0,   0],
                        [29,  3,   4 ,  0 ,  0,   4,   0,   0],
                        [30,  3,   5 ,  5 ,  0,   3,   0,   0],
                        [31,  3,   6 ,  0 ,  0,   4,   0,   0],
                        [32,  3,   7 ,  0 ,  0,   4,   0,   0],
                        [33,  3,   8 ,  0 ,  0,   2,   0,   0],
                        [34,  3,   9 ,  0 ,  0,   4,   0,   0],
                        [35,  3,   10,  10,  0,   1,   0,   1],
                        [36,  3,   11,  0 ,  0,   4,   0,   0],
                        [37,  3,   12,  0 ,  0,   3,   0,   0],
                        [38,  3,   13,  10,  0,   1,   0,   0],
                        [39,  4,   1 ,  0 ,  0,   3,   0,   0],
                        [40,  4,   2 ,  0 ,  1,   4,   0,   0],
                        [41,  4,   3 ,  0 ,  0,   3,   0,   0],
                        [42,  4,   4 ,  0 ,  0,   2,   0,   0],
                        [43,  4,   5 ,  5 ,  0,   1,   0,   1],
                        [44,  4,   6 ,  0 ,  0,   2,   0,   0],
                        [45,  4,   7 ,  0 ,  0,   1,   0,   1],
                        [46,  4,   8 ,  0 ,  0,   2,   0,   0],
                        [47,  4,   9 ,  0 ,  0,   1,   0,   1],
                        [48,  4,   10,  10,  0,   4,   0,   0],
                        [49,  4,   11,  0 ,  0,   2,   0,   0],
                        [50,  4,   12,  0 ,  0,   3,   0,   0],
                        [51,  4,   13,  10,  0,   2,   0,   0],
                        [52,  5,   14,  0 ,  1,   2,   0,   0],
                        [53,  6,   15,  0 ,  1,   3,   0,   0]], dtype=np.int16 )

# 3 ideas
#1, method test with standalone data object. 完整methods
#2, method test with running data object. 可能是method中的一部分
#3, single method vs. nested method. 复杂高层调用

class PlayGuess_CNN_UT(PlayGuess_CNN):
    def __init__(self, batch_size):
        self.batch_size = batch_size  # =10 only
        super().__init__( hidden_layers={'input_net':{'conv_filters': [16, 32], 'kernal_sizes':[3, 2], 'strides':[(1,2), (1,2)]}, 'output_net':{'conv_filter': 64,  'kernal_size':2, 'stride':(1,1)}},
                          filename_g='', learning_rate=0.00001, reload=False, learning_amount=2000, residual=False)
    
    #case1-4: Tto be added later. need much effort in data creation
    def test_guess_calc_length_1(self, state3s_batch1, guess_inhand, guess_discard, unknown_cards, players_inhand_length, guess_env_callback):
        #CNN input state3s_batch.shape=(10,5,54). but guess_calc() need (10,5,54)

        #case1: 1 played in a round. (banker played)
        state3s_batch1[0, 0, 9] = 0
        state3s_batch1[0, 1, 9] = 1
        
        guess_inhand = guess_inhand
        guess_discard = guess_discard
        unknown_cards = unknown_cards
        players_inhand_length = players_inhand_length
        
        state3s_batch  = state3s_batch1[:,:,:,np.newaxis]
        guess_cards = self.guess_calc(state3s_batch, guess_inhand, guess_discard, unknown_cards, copy.deepcopy(players_inhand_length), guess_env_callback)
        
        result_len0 = np.where(guess_cards!=0, 1, 0)
        result_len = np.sum(result_len0, axis=2)
        expected_length = np.array([12]*self.batch_size)
        return True  #((result_len == expected_length).all())
        
    def test_guess_calc_length_2(self, state3s_batch1, guess_inhand, guess_discard, unknown_cards, players_inhand_length, guess_env_callback):
        return True  #((result_len == expected_length).all())
        
    def test_guess_calc_length_3(self, state3s_batch1, guess_inhand, guess_discard, unknown_cards, players_inhand_length, guess_env_callback):
        return True  #((result_len == expected_length).all())

    def test_guess_calc_length_4(self, state3s_batch1, guess_inhand, guess_discard, unknown_cards, players_inhand_length, guess_env_callback):
        return True  #((result_len == expected_length).all())

    def TEST_guess_calc_length(self):
        ######################################
        # base DATA preparation: 
        #   NO global data impacted
        #   NO env, proxy, full_poker object imapced
        ######################################
        # base INPUT preparation: 
        #   envs: UT defined guess_callback()
        #   guess_inhand
        #   guess_discard,
        #   unknown_cards
        #   players_inhand_length
        # 
        # purposes: guessed length checking: 
        #     input: (n,n,n)     ==> (n,n,n):       0 or 3 players played of the round; current is banker
        #                        ==> (n,n,n+6),     0 or 3 players played of the round; banker is at n+6; 
        #                        ==> (n,n+6,n),     0 or 3 players played of the round; banker is at n+6; 
        #                        ==> (n+6,n,n):     0 or 3 players played of the round; banker is at n+6; 
        #
        #            (n+1,n+1,n) ==> (n+1,n+1,n):   1 player played; current is banker
        #                        ==> (n+1,n+1,n+6): 1 player played; banker already played; banker at n+6
        #                        ==> (n+1,n+7,n),   1 player played; banker at n+7
        #                        ==> (n+7,n+1,n),   1 player played; banker at n+7
        #
        #            (n+1,n,n)   ==> (n+1,n,n),     2 players played; current is banker
        #                        ==> (n+1,n,n+6),   2 players played; banker at n+6
        #                        ==> (n+1,n+6,n),   2 players played; banker at n+6
        #                        ==> (n+7,n,n),     2 players played; banker at n+7
        #
        def guess_env_callback(action, data=0):
            if 0 == action:  #fmt for every cards. doesn't identify 'discard'
                guess_cards3 = data
                #in decide(), input shape=(<n,1>, 3, 54). 1=1by1; n=4in1. for guess, to identify fmt0, 2, 3
                #in learning(), input shape=(11*n*<4,1>, 3, 54); 1=1by1; 4=4in1(4 players)
                fmts = [0, -1, 0.5, 1] #self.net_input_format
        
                # !!! limitation: assume round===2 with SPADE. the trump is same crossing cardsets !!!
                trumps0 = np.array([[1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	1]])   #self.full_poker.np_cards[0,:,dc.COL_TRUMP][np.newaxis, :]
                trumps = np.where(trumps0 == True, fmts[3], fmts[2])[:, np.newaxis, :]  #shape不同，但只有一dim不同，且dim=1，可以+,-,*,/操做
                guess_cards = guess_cards3 * trumps
    
                ret = guess_cards
    
            elif 1 == action : #am I 庄家?
                state3s_batch = data  #标准state3
                #in CNN: input shape=(n,5,54,1)
                #in DNN: input shape=(n,5*54)
                state3s_batch_shape = state3s_batch.shape
                state3s_batch = state3s_batch.reshape(state3s_batch_shape[0], 5, 54)
                
                fmts = [0, -1, 0.5, 1] #self.net_input_format
                discards = np.where(state3s_batch[:,0,:] == fmts[1], 1, 0)
                discard_sum6 = np.sum(discards, axis=1)
                banker_yes = (discard_sum6==6)
                
                ret = banker_yes
                
            elif 2 == action : #庄家在[0，1，2，3]的位置
                ret = banker_pos  #self.banker_pos
                
            elif 3 == action : #
                ret = [0, -1, 0.5, 1] #self.net_input_format
                
            return ret
        
        results = []

        ### case0: the first play in a game: banker starts #######
        state3s_batch0 = np.array([
                                [[1,	0,	0,	1,	0,	0,	0,	1,	0,	1,	0,	0,	1,	0,	1,	0,	-1,	-1,	0,	0,	-1,	0,	0,	0,	-1,	0,	0.5,	0,	0,	0,	0,	-1,	0,	0,	0,	0.5,	0,	0,	0,	0.5,	0,	0,	0,	0,	0,	0,	-1,	0,	0,	0,	0,	0.5,	1,	1],
                                 [1,	0,	-1,	0,	1,	0,	1,	1,	0,	0,	1,	0,	0,	0,	0,	-1,	0,	0.5,	0,	0,	0,	0,	0.5,	0,	0,	-1,	0.5,	0,	0,	0,	0,	-1,	-1,	0.5,	0,	0,	0,	0,	0,	0.5,	0,	0,	0,	0,	0,	0,	0,	-1,	0.5,	0,	0,	0,	1,	0],
                                 [0,	0,	1,	0,	0,	1,	1,	0,	1,	0,	0,	1,	0,	0,	0,	0,	0,	0.5,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	-1,	-1,	0.5,	-1,	0,	0,	0,	0.5,	0,	-1,	0,	0,	1,	-1,	0,	0.5,	0.5,	0,	0,	-1,	0.5,	0,	0,	0,	0,	0],
                                 [0,	0,	1,	0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0.5,	1,	0,	-1,	0,	0,	0,	0.5,	0,	0,	0,	0.5,	0,	0.5,	0,	-1,	0,	0,	-1,	0,	0,	-1,	0.5,	0,	0,	0,	0,	0,	0,	0,	0.5,	0,	-1,	0,	-1,	0,	0.5,	0,	0.5,	0,	1],
                                 [0,	0,	0,	0,	0,	1,	0,	0,	0,	0,	1,	0,	0,	0,	1,	0,	0,	0.5,	0.5,	0,	0,	0,	0,	0.5,	0.5,	-1,	0,	1,	-1,	-1,	0,	-1,	0,	0.5,	-1,	0.5,	0,	0.5,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	-1,	0,	0.5,	0,	0,	0],
                                 [1,	1,	0,	1,	1,	0,	0,	1,	0,	0,	0,	0,	0,	0.5,	1,	-1,	-1,	0,	0,	0,	0.5,	-1,	0,	0,	0,	0,	0.5,	0,	0,	0,	0,	0,	-1,	0,	0,	0.5,	0,	-1,	0,	0.5,	0,	0,	-1,	0,	0,	0,	0,	0,	0.5,	0,	0,	0,	0,	0],
                                 [0,	0,	1,	1,	0,	0,	0,	1,	0,	1,	0,	0,	0,	0,	1,	0,	-1,	0.5,	0,	0,	-1,	0,	0.5,	-1,	0,	0,	0.5,	0,	0,	0,	0,	0,	0,	0,	0,	0.5,	0,	0,	0.5,	0,	0,	0,	-1,	0,	-1,	-1,	0,	0,	0.5,	0,	0,	0,	1,	0],
                                 [0,	0,	0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0.5,	0,	-1,	0,	0,	0.5,	0.5,	0,	0.5,	0,	0,	0.5,	0.5,	0.5,	0,	0,	0,	0.5,	0,	-1,	0.5,	0,	0,	0,	0,	0,	0.5,	0,	-1,	0,	0.5,	-1,	-1,	-1,	0,	0,	0,	0,	0,	0,	0],
                                 [1,	0,	1,	1,	0,	0,	1,	0,	0,	0,	0,	1,	0,	0,	0,	0,	0,	0.5,	0.5,	0,	0,	0,	0,	0.5,	0.5,	0,	0.5,	0,	-1,	0,	0,	0,	0,	0,	-1,	0,	-1,	-1,	0,	0,	0,	-1,	0,	0,	0,	-1,	0,	0,	0,	0,	0,	0.5,	0,	1],
                                 [0,	0,	1,	1,	0,	1,	0,	0,	0,	0,	1,	0,	1,	0,	0,	0,	0,	0.5,	0,	0,	0,	0,	0.5,	0,	-1,	0,	0,	0,	-1,	-1,	0,	-1,	0,	0.5,	0,	0,	0,	0,	0.5,	0,	0,	0,	0,	0.5,	-1,	0,	0,	0,	0.5,	0,	-1,	0,	0,	1]],
                                
                                
                                [[0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0]],
                                
                                
                                [[0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0]],
                                
                                
                                [[0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0]],
                                
                                
                                [[0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0],
                                 [0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0]]
                                ])
        

        guess_inhand0 = np.array([
                                [[0.499179,	0.494027,	0.498091,	0.500021,	0.494369,	0.514269,	0.508114,	0.505309,	0.495323,	0.502078,	0.491942,	0.507008,	0.498938,	0.49867,	0.507699,	0.491723,	0.495586,	0.494416,	0.499481,	0.501994,	0.496509,	0.506466,	0.493429,	0.501779,	0.504411,	0.507122,	0.502981,	0.503924,	0.508472,	0.49733,	0.505177,	0.496017,	0.508533,	0.496263,	0.495879,	0.497673,	0.50524,	0.501619,	0.504361,	0.50338,	0.497171,	0.501857,	0.50416,	0.491554,	0.502735,	0.501233,	0.498253,	0.499177,	0.495861,	0.501017,	0.502717,	0.498191,	0.493784,	0.505672],
                                 [0.505466,	0.499879,	0.494559,	0.503955,	0.494238,	0.512876,	0.50222,	0.503063,	0.495297,	0.489461,	0.488257,	0.495614,	0.496507,	0.508345,	0.506302,	0.499731,	0.494232,	0.494067,	0.495087,	0.504004,	0.498241,	0.5018,	0.499717,	0.503837,	0.505001,	0.501795,	0.495578,	0.500651,	0.505333,	0.493106,	0.50194,	0.507075,	0.502905,	0.490521,	0.495337,	0.495517,	0.499694,	0.497817,	0.50039,	0.507892,	0.510165,	0.495642,	0.509953,	0.49978,	0.505466,	0.505003,	0.505686,	0.49239,	0.494525,	0.504224,	0.505083,	0.497949,	0.493448,	0.50156],
                                 [0.509286,	0.494278,	0.503823,	0.499257,	0.500549,	0.518468,	0.49012,	0.506009,	0.498074,	0.488081,	0.489054,	0.502197,	0.500737,	0.498281,	0.503913,	0.496981,	0.504969,	0.501393,	0.490039,	0.496631,	0.495398,	0.504472,	0.493002,	0.501427,	0.504036,	0.499679,	0.504632,	0.500468,	0.49927,	0.491963,	0.50301,	0.499761,	0.497801,	0.498762,	0.498112,	0.50045,	0.503825,	0.504605,	0.503701,	0.498929,	0.505566,	0.489166,	0.507923,	0.501449,	0.503385,	0.501953,	0.500755,	0.495595,	0.493856,	0.503506,	0.500064,	0.496908,	0.483927,	0.501116],
                                 [0.506991,	0.490494,	0.509288,	0.499707,	0.508551,	0.51148,	0.5039,	0.506716,	0.497285,	0.496312,	0.487443,	0.500981,	0.501068,	0.506031,	0.498132,	0.503549,	0.495978,	0.506596,	0.493865,	0.496776,	0.497039,	0.487732,	0.496006,	0.510826,	0.508988,	0.504173,	0.493128,	0.497303,	0.507708,	0.500343,	0.502347,	0.494327,	0.505734,	0.491253,	0.49934,	0.493689,	0.501039,	0.506944,	0.507306,	0.492356,	0.502558,	0.503288,	0.504131,	0.50278,	0.506593,	0.5,	0.505175,	0.497053,	0.498213,	0.502207,	0.504295,	0.498939,	0.490883,	0.500687],
                                 [0.503073,	0.491481,	0.490051,	0.506633,	0.501157,	0.508885,	0.499217,	0.513465,	0.499082,	0.495459,	0.492261,	0.503246,	0.498735,	0.504941,	0.50557,	0.495223,	0.503584,	0.499866,	0.495971,	0.499297,	0.504754,	0.506642,	0.495685,	0.499107,	0.499544,	0.492797,	0.496265,	0.501984,	0.498399,	0.4953,	0.502102,	0.500744,	0.49818,	0.504053,	0.5018,	0.499856,	0.499555,	0.503965,	0.503939,	0.504707,	0.499217,	0.500579,	0.50399,	0.504925,	0.509103,	0.500627,	0.503923,	0.499178,	0.501737,	0.502989,	0.502167,	0.501269,	0.493647,	0.489474],
                                 [0.500605,	0.498548,	0.501882,	0.501113,	0.499136,	0.507872,	0.494528,	0.51043,	0.495105,	0.498973,	0.498056,	0.503035,	0.500443,	0.500476,	0.500388,	0.502986,	0.501077,	0.504286,	0.502236,	0.505757,	0.496119,	0.49682,	0.490215,	0.501175,	0.495645,	0.503245,	0.507948,	0.497682,	0.495865,	0.485917,	0.501295,	0.497864,	0.505308,	0.496149,	0.493581,	0.494658,	0.503247,	0.506281,	0.510524,	0.502313,	0.500851,	0.497681,	0.507574,	0.502266,	0.505535,	0.501823,	0.497076,	0.495544,	0.497501,	0.493128,	0.508506,	0.500103,	0.494305,	0.504188],
                                 [0.49829,	0.499477,	0.501055,	0.495985,	0.494775,	0.502263,	0.502635,	0.502796,	0.499279,	0.494984,	0.495106,	0.507174,	0.496526,	0.493572,	0.504145,	0.494978,	0.502112,	0.497517,	0.495737,	0.505772,	0.494301,	0.503241,	0.495897,	0.509216,	0.504349,	0.509513,	0.498346,	0.495598,	0.50155,	0.490292,	0.508457,	0.502357,	0.510273,	0.492002,	0.50569,	0.496097,	0.499742,	0.505753,	0.501563,	0.495871,	0.50269,	0.500353,	0.508459,	0.499431,	0.500653,	0.504223,	0.506284,	0.498495,	0.498956,	0.505559,	0.506055,	0.497578,	0.4867,	0.495296],
                                 [0.505599,	0.501772,	0.507902,	0.508059,	0.495394,	0.507988,	0.502269,	0.500861,	0.501536,	0.49383,	0.49056,	0.502245,	0.502762,	0.504277,	0.498494,	0.494243,	0.499001,	0.498772,	0.498187,	0.496403,	0.502543,	0.494455,	0.499881,	0.500232,	0.507834,	0.503131,	0.50296,	0.502632,	0.510185,	0.498638,	0.513138,	0.5044,	0.495014,	0.493701,	0.502099,	0.499362,	0.508896,	0.495684,	0.505534,	0.497932,	0.506947,	0.498493,	0.504002,	0.497177,	0.506704,	0.508742,	0.503467,	0.498553,	0.489917,	0.504462,	0.507768,	0.495133,	0.49024,	0.496248],
                                 [0.506776,	0.500021,	0.513645,	0.501571,	0.496271,	0.504437,	0.494676,	0.506137,	0.493352,	0.486875,	0.493005,	0.502076,	0.499884,	0.500818,	0.501484,	0.502679,	0.494996,	0.505392,	0.491467,	0.49882,	0.497831,	0.498891,	0.50212,	0.508602,	0.505493,	0.508343,	0.500859,	0.499988,	0.504093,	0.492291,	0.504911,	0.50002,	0.49653,	0.493817,	0.497993,	0.500219,	0.500891,	0.499489,	0.501212,	0.494108,	0.502518,	0.500242,	0.50082,	0.499543,	0.502172,	0.500056,	0.500362,	0.494762,	0.501401,	0.497972,	0.502085,	0.497499,	0.495293,	0.502539],
                                 [0.507447,	0.494318,	0.503584,	0.499299,	0.504912,	0.511492,	0.493171,	0.507718,	0.496896,	0.496411,	0.493957,	0.504061,	0.50145,	0.505121,	0.510524,	0.494776,	0.501484,	0.499573,	0.499824,	0.497321,	0.497604,	0.505829,	0.495772,	0.50656,	0.512956,	0.491617,	0.502803,	0.500022,	0.496944,	0.502526,	0.508035,	0.500475,	0.495653,	0.49635,	0.499277,	0.503175,	0.508332,	0.504482,	0.499877,	0.498256,	0.512687,	0.497609,	0.504874,	0.505262,	0.503126,	0.505453,	0.501346,	0.491472,	0.501628,	0.505508,	0.505435,	0.494437,	0.487114,	0.498003]],

                                [[0.49408,	0.499069,	0.494815,	0.501742,	0.497051,	0.489024,	0.502499,	0.499063,	0.497687,	0.501152,	0.498372,	0.48866,	0.496403,	0.501665,	0.50254,	0.515728,	0.504651,	0.506309,	0.494514,	0.504382,	0.497921,	0.502523,	0.504877,	0.490609,	0.486039,	0.499949,	0.503075,	0.494557,	0.51023,	0.499814,	0.501697,	0.501825,	0.504776,	0.502255,	0.50126,	0.505658,	0.495901,	0.510284,	0.493131,	0.50372,	0.488762,	0.496314,	0.499747,	0.500894,	0.498651,	0.495449,	0.496731,	0.499558,	0.50194,	0.497244,	0.4989,	0.50124,	0.502838,	0.495912],
                                 [0.497173,	0.502761,	0.497528,	0.495569,	0.498056,	0.492516,	0.498859,	0.497295,	0.485024,	0.498731,	0.494096,	0.486648,	0.495049,	0.50878,	0.498826,	0.496703,	0.507373,	0.508023,	0.504967,	0.501143,	0.490834,	0.506108,	0.506826,	0.497374,	0.492235,	0.495939,	0.499172,	0.504785,	0.502745,	0.496628,	0.500007,	0.507054,	0.511182,	0.499452,	0.509444,	0.509821,	0.504532,	0.507924,	0.491365,	0.502972,	0.494024,	0.503272,	0.497698,	0.50703,	0.502375,	0.493237,	0.497113,	0.491012,	0.500832,	0.503028,	0.4924,	0.504298,	0.500399,	0.49064],
                                 [0.498519,	0.496269,	0.506192,	0.494828,	0.492948,	0.492113,	0.499158,	0.504459,	0.492073,	0.496343,	0.489708,	0.497086,	0.501642,	0.511057,	0.500487,	0.504585,	0.498949,	0.507148,	0.495696,	0.507807,	0.494207,	0.504948,	0.502038,	0.499639,	0.494771,	0.492795,	0.492588,	0.489663,	0.502622,	0.503341,	0.509046,	0.505983,	0.501909,	0.510903,	0.504552,	0.508484,	0.495755,	0.50222,	0.492687,	0.498395,	0.481153,	0.504691,	0.502163,	0.509526,	0.50554,	0.498817,	0.504387,	0.49907,	0.4954,	0.498712,	0.509215,	0.507191,	0.49631,	0.487697],
                                 [0.484474,	0.49979,	0.49052,	0.495516,	0.497707,	0.495394,	0.494359,	0.498984,	0.50405,	0.501885,	0.496923,	0.496354,	0.500421,	0.506353,	0.501794,	0.502607,	0.512193,	0.515798,	0.49727,	0.504765,	0.501539,	0.507146,	0.500593,	0.498613,	0.491822,	0.497595,	0.499021,	0.491323,	0.506871,	0.502402,	0.499184,	0.503799,	0.499408,	0.496943,	0.507543,	0.507282,	0.505886,	0.505205,	0.498055,	0.495305,	0.493421,	0.507641,	0.499381,	0.507541,	0.499497,	0.500807,	0.495624,	0.501934,	0.494193,	0.498394,	0.498787,	0.504227,	0.497027,	0.483997],
                                 [0.492718,	0.492296,	0.493629,	0.4924,	0.49957,	0.490503,	0.503459,	0.501704,	0.49015,	0.489523,	0.496689,	0.498337,	0.497728,	0.50939,	0.49338,	0.512423,	0.49346,	0.499795,	0.4939,	0.499308,	0.49708,	0.498749,	0.506208,	0.489477,	0.500883,	0.493312,	0.488917,	0.489986,	0.496935,	0.503596,	0.503352,	0.502487,	0.514635,	0.502391,	0.498893,	0.506303,	0.495459,	0.503815,	0.489555,	0.500366,	0.490965,	0.497249,	0.495276,	0.499097,	0.502987,	0.493916,	0.497604,	0.503429,	0.503879,	0.496956,	0.496416,	0.502809,	0.483519,	0.495627],
                                 [0.488688,	0.492303,	0.501823,	0.499567,	0.493734,	0.486065,	0.50126,	0.506473,	0.485848,	0.496789,	0.498769,	0.490693,	0.497917,	0.503537,	0.495219,	0.499262,	0.493145,	0.501138,	0.496912,	0.508017,	0.499589,	0.499782,	0.505388,	0.50382,	0.495488,	0.491934,	0.496355,	0.495558,	0.50155,	0.498708,	0.501197,	0.498163,	0.512326,	0.504508,	0.505269,	0.505105,	0.49575,	0.503221,	0.487199,	0.49971,	0.488361,	0.500858,	0.497757,	0.506244,	0.499014,	0.491442,	0.495359,	0.500358,	0.498645,	0.498629,	0.497012,	0.506652,	0.497552,	0.490618],
                                 [0.491088,	0.49528,	0.497679,	0.491999,	0.49659,	0.493645,	0.496391,	0.490679,	0.496672,	0.495788,	0.486652,	0.486311,	0.493398,	0.503988,	0.499369,	0.501889,	0.501709,	0.50886,	0.492567,	0.491104,	0.502307,	0.504796,	0.504183,	0.489166,	0.494956,	0.497463,	0.499209,	0.500089,	0.504684,	0.507249,	0.498878,	0.501962,	0.503153,	0.510372,	0.504805,	0.507583,	0.501483,	0.497071,	0.488286,	0.500951,	0.487442,	0.496471,	0.494791,	0.505762,	0.506952,	0.489327,	0.492896,	0.500806,	0.494302,	0.502006,	0.493054,	0.501016,	0.499861,	0.495976],
                                 [0.489094,	0.502504,	0.503762,	0.497438,	0.501431,	0.497359,	0.506865,	0.500696,	0.498591,	0.491072,	0.502401,	0.492611,	0.50312,	0.493605,	0.493848,	0.50199,	0.516687,	0.509488,	0.494937,	0.494843,	0.496257,	0.501029,	0.506731,	0.500151,	0.490334,	0.491357,	0.500726,	0.497107,	0.506422,	0.507537,	0.496938,	0.502777,	0.494997,	0.50316,	0.508592,	0.513033,	0.496631,	0.501307,	0.494348,	0.500037,	0.493005,	0.503358,	0.500241,	0.498351,	0.500627,	0.492419,	0.499916,	0.500733,	0.492972,	0.493321,	0.503891,	0.497745,	0.49646,	0.506079],
                                 [0.486164,	0.496035,	0.501717,	0.501985,	0.498894,	0.493209,	0.505047,	0.497835,	0.499018,	0.497104,	0.499815,	0.4882,	0.503533,	0.507955,	0.497592,	0.504493,	0.510624,	0.512217,	0.495174,	0.505373,	0.501496,	0.502453,	0.507041,	0.494419,	0.492923,	0.493134,	0.499397,	0.495498,	0.500301,	0.497322,	0.503329,	0.50185,	0.49698,	0.502916,	0.504821,	0.502895,	0.50785,	0.504962,	0.491729,	0.495987,	0.493361,	0.509245,	0.498154,	0.500923,	0.509545,	0.491008,	0.492279,	0.501391,	0.498357,	0.499285,	0.496112,	0.504157,	0.498273,	0.492745],
                                 [0.497092,	0.495115,	0.492181,	0.495083,	0.49686,	0.489952,	0.506013,	0.505682,	0.495692,	0.492698,	0.503614,	0.497628,	0.49855,	0.512222,	0.494265,	0.507712,	0.508173,	0.499632,	0.493454,	0.498825,	0.495846,	0.496053,	0.501364,	0.495154,	0.496873,	0.490546,	0.485985,	0.49042,	0.496638,	0.506594,	0.507071,	0.493681,	0.504519,	0.493838,	0.508424,	0.50519,	0.501928,	0.502222,	0.495928,	0.500421,	0.478984,	0.50437,	0.499761,	0.498528,	0.502985,	0.498683,	0.499795,	0.497422,	0.491771,	0.499925,	0.497199,	0.505835,	0.486619,	0.490851]],

                                [[0.502114,	0.496933,	0.49576,	0.506168,	0.503248,	0.504441,	0.51199,	0.506737,	0.497095,	0.49923,	0.489215,	0.515265,	0.504431,	0.505257,	0.507154,	0.498856,	0.502468,	0.505614,	0.505367,	0.503299,	0.502103,	0.498621,	0.499513,	0.506037,	0.496807,	0.496944,	0.500716,	0.509401,	0.508514,	0.502128,	0.501416,	0.500815,	0.499396,	0.494384,	0.491256,	0.497644,	0.504071,	0.501739,	0.494845,	0.51118,	0.49231,	0.499219,	0.498356,	0.496145,	0.507324,	0.502426,	0.494928,	0.506164,	0.50349,	0.504141,	0.49724,	0.503878,	0.501909,	0.496632],
                                 [0.508692,	0.5038,	0.503933,	0.511067,	0.495711,	0.502342,	0.504664,	0.50254,	0.501504,	0.494355,	0.484629,	0.502592,	0.500375,	0.511077,	0.501989,	0.503309,	0.501846,	0.498833,	0.50412,	0.491199,	0.498363,	0.512178,	0.505126,	0.500874,	0.496282,	0.502034,	0.495698,	0.504337,	0.5166,	0.498565,	0.506675,	0.499253,	0.505864,	0.500317,	0.494065,	0.491219,	0.502314,	0.496893,	0.489343,	0.511537,	0.498251,	0.500781,	0.491959,	0.48482,	0.507921,	0.49838,	0.498165,	0.499117,	0.509191,	0.503788,	0.504924,	0.506546,	0.501892,	0.491257],
                                 [0.503862,	0.504368,	0.50465,	0.507663,	0.501095,	0.495018,	0.504112,	0.504403,	0.486977,	0.504144,	0.493308,	0.505531,	0.506972,	0.50526,	0.493591,	0.497221,	0.499829,	0.493679,	0.506428,	0.501119,	0.501269,	0.503879,	0.503533,	0.496322,	0.501629,	0.50064,	0.501852,	0.504321,	0.500032,	0.499605,	0.505342,	0.506212,	0.502409,	0.502794,	0.491669,	0.487573,	0.499458,	0.494045,	0.50705,	0.500787,	0.494193,	0.497011,	0.494752,	0.491136,	0.50438,	0.499287,	0.498698,	0.488224,	0.503682,	0.509152,	0.49305,	0.505166,	0.498481,	0.497781],
                                 [0.505902,	0.49431,	0.501434,	0.507253,	0.496361,	0.491089,	0.507558,	0.501279,	0.489997,	0.491001,	0.494461,	0.511788,	0.504005,	0.504913,	0.503527,	0.499008,	0.497622,	0.502509,	0.498378,	0.497291,	0.508401,	0.503728,	0.493794,	0.498492,	0.502999,	0.499506,	0.501171,	0.501951,	0.504532,	0.49829,	0.50221,	0.497141,	0.50586,	0.496841,	0.502503,	0.498666,	0.504646,	0.506946,	0.496517,	0.506694,	0.50127,	0.500343,	0.496933,	0.48208,	0.493955,	0.500575,	0.496572,	0.487447,	0.508323,	0.501481,	0.498987,	0.50828,	0.501419,	0.496423],
                                 [0.505851,	0.498548,	0.495129,	0.503528,	0.4982,	0.504412,	0.509256,	0.492821,	0.497624,	0.50982,	0.502021,	0.504895,	0.496528,	0.512758,	0.490863,	0.496262,	0.495943,	0.495746,	0.507009,	0.50311,	0.503731,	0.502619,	0.508483,	0.495484,	0.505305,	0.498017,	0.489084,	0.505654,	0.501136,	0.497541,	0.505874,	0.499057,	0.499333,	0.501574,	0.497204,	0.496583,	0.50038,	0.498497,	0.503327,	0.505445,	0.489114,	0.500817,	0.495541,	0.49182,	0.511389,	0.498962,	0.497937,	0.499628,	0.502667,	0.500213,	0.500705,	0.501199,	0.498019,	0.50145],
                                 [0.497414,	0.497376,	0.494589,	0.506928,	0.502209,	0.49663,	0.510367,	0.503289,	0.504553,	0.503399,	0.49379,	0.507983,	0.496927,	0.505398,	0.497338,	0.504805,	0.500073,	0.495634,	0.503352,	0.495682,	0.499798,	0.504396,	0.499887,	0.49589,	0.505751,	0.487045,	0.500405,	0.503774,	0.500278,	0.499415,	0.50261,	0.494147,	0.499014,	0.491805,	0.502445,	0.498408,	0.499349,	0.5008,	0.498414,	0.50501,	0.494943,	0.492824,	0.496142,	0.489561,	0.509167,	0.498813,	0.494375,	0.497444,	0.510216,	0.503811,	0.499877,	0.503421,	0.50198,	0.492423],
                                 [0.506714,	0.494907,	0.492107,	0.508067,	0.503927,	0.494023,	0.505276,	0.503805,	0.500217,	0.496316,	0.488885,	0.509373,	0.502056,	0.496701,	0.501173,	0.495522,	0.501427,	0.500716,	0.508218,	0.497729,	0.50502,	0.496694,	0.501619,	0.499223,	0.490617,	0.494875,	0.493999,	0.497423,	0.503449,	0.503491,	0.504264,	0.501894,	0.494742,	0.504323,	0.491122,	0.491152,	0.499936,	0.499595,	0.49337,	0.508126,	0.495816,	0.496677,	0.495798,	0.496189,	0.506099,	0.500893,	0.500888,	0.496663,	0.498699,	0.507401,	0.503854,	0.500898,	0.498996,	0.493058],
                                 [0.49574,	0.505771,	0.506176,	0.506533,	0.499979,	0.491786,	0.505734,	0.508017,	0.496425,	0.501816,	0.489235,	0.505255,	0.508978,	0.50392,	0.498572,	0.492542,	0.497633,	0.502762,	0.50269,	0.495387,	0.505809,	0.495955,	0.502644,	0.495731,	0.502866,	0.493389,	0.494797,	0.504741,	0.510916,	0.498164,	0.51076,	0.500518,	0.495364,	0.507263,	0.497019,	0.492603,	0.507242,	0.501179,	0.498444,	0.502341,	0.494517,	0.49682,	0.503989,	0.488245,	0.50437,	0.488528,	0.501977,	0.498024,	0.501741,	0.491421,	0.492286,	0.498108,	0.49452,	0.495541],
                                 [0.505101,	0.494659,	0.507141,	0.503659,	0.496507,	0.494215,	0.503933,	0.507865,	0.507151,	0.499254,	0.497963,	0.506854,	0.49968,	0.503377,	0.498728,	0.494824,	0.496684,	0.506444,	0.499975,	0.493665,	0.504799,	0.508098,	0.493038,	0.488354,	0.496434,	0.491649,	0.494166,	0.502333,	0.505254,	0.494548,	0.495893,	0.498472,	0.501866,	0.500704,	0.496818,	0.497058,	0.496751,	0.508453,	0.49915,	0.498678,	0.498809,	0.491128,	0.497631,	0.495808,	0.495722,	0.500197,	0.493394,	0.493426,	0.509554,	0.503391,	0.503678,	0.505883,	0.497394,	0.496584],
                                 [0.503262,	0.492524,	0.502584,	0.498575,	0.499415,	0.496128,	0.495979,	0.496073,	0.491922,	0.501249,	0.493034,	0.499409,	0.508924,	0.508994,	0.497162,	0.493025,	0.501902,	0.496761,	0.506068,	0.500527,	0.502053,	0.50295,	0.502792,	0.496415,	0.500152,	0.49026,	0.493251,	0.499557,	0.498327,	0.505779,	0.496265,	0.502331,	0.502067,	0.505404,	0.502785,	0.495171,	0.497127,	0.500985,	0.500881,	0.496711,	0.495701,	0.496168,	0.490041,	0.487285,	0.502072,	0.499973,	0.495815,	0.489548,	0.505798,	0.503841,	0.505587,	0.509673,	0.491622,	0.496197]]
                                ])
        
    
        guess_discard0 = np.array([
        							[0.513309,	0.498081,	0.505519,	0.497764,	0.494066,	0.504401,	0.500987,	0.49178,	0.492871,	0.500962,	0.503515,	0.500058,	0.489793,	0.494729,	0.502481,	0.499933,	0.495791,	0.505949,	0.504871,	0.497759,	0.504062,	0.49252,	0.504115,	0.506889,	0.495381,	0.499872,	0.502893,	0.506016,	0.500381,	0.488789,	0.498121,	0.507346,	0.494772,	0.491343,	0.495589,	0.488771,	0.501161,	0.506025,	0.491688,	0.492301,	0.499647,	0.499859,	0.499305,	0.502428,	0.496323,	0.510821,	0.486546,	0.491524,	0.505136,	0.493704,	0.502398,	0.495875,	0.506093,	0.495262],
        							[0.504279,	0.500838,	0.510325,	0.493771,	0.495082,	0.503284,	0.505096,	0.498555,	0.498808,	0.493361,	0.498006,	0.495163,	0.483348,	0.493358,	0.497072,	0.504216,	0.505254,	0.503009,	0.499223,	0.502128,	0.515142,	0.496939,	0.501767,	0.50995,	0.505902,	0.503043,	0.498794,	0.493694,	0.495829,	0.493178,	0.505908,	0.503607,	0.497887,	0.50159,	0.498525,	0.497317,	0.502194,	0.496764,	0.507177,	0.495847,	0.504155,	0.501088,	0.503179,	0.505117,	0.502843,	0.495212,	0.50069,	0.491462,	0.503549,	0.49214,	0.502738,	0.499339,	0.5026,	0.503876],
        							[0.50097,	0.498698,	0.507809,	0.486932,	0.502326,	0.508169,	0.506984,	0.499029,	0.49987,	0.511812,	0.496486,	0.495951,	0.494987,	0.49915,	0.494247,	0.503465,	0.482776,	0.503729,	0.488729,	0.501025,	0.507729,	0.493537,	0.511672,	0.504427,	0.49711,	0.499279,	0.504548,	0.500847,	0.501267,	0.486061,	0.504144,	0.504577,	0.501809,	0.506639,	0.507684,	0.502426,	0.498456,	0.49986,	0.503209,	0.500338,	0.503651,	0.49951,	0.506464,	0.500731,	0.513466,	0.491299,	0.496032,	0.499078,	0.499548,	0.491412,	0.488237,	0.500201,	0.493755,	0.513552],
        							[0.51006,	0.494015,	0.507597,	0.499716,	0.5049,	0.496163,	0.507905,	0.491157,	0.499864,	0.511214,	0.490216,	0.496922,	0.483709,	0.493925,	0.508299,	0.50892,	0.491345,	0.500045,	0.494554,	0.493692,	0.508011,	0.497936,	0.502085,	0.510503,	0.494606,	0.491776,	0.499077,	0.499869,	0.502705,	0.493048,	0.50477,	0.501321,	0.503877,	0.483655,	0.501747,	0.49922,	0.495975,	0.496325,	0.499894,	0.49365,	0.506351,	0.498415,	0.499952,	0.507861,	0.500557,	0.504916,	0.490503,	0.490734,	0.492817,	0.489552,	0.493793,	0.495973,	0.506704,	0.501526],
        							[0.503935,	0.503291,	0.506679,	0.493836,	0.495176,	0.510554,	0.510837,	0.496987,	0.495692,	0.50094,	0.495073,	0.49141,	0.492697,	0.495425,	0.498622,	0.513999,	0.498801,	0.499381,	0.496785,	0.502526,	0.510537,	0.4961,	0.501972,	0.501419,	0.501372,	0.49747,	0.503032,	0.505202,	0.496521,	0.501298,	0.49508,	0.507296,	0.496858,	0.506361,	0.497453,	0.504257,	0.499874,	0.502464,	0.500956,	0.49067,	0.505994,	0.498047,	0.50587,	0.507423,	0.50499,	0.501329,	0.492545,	0.502506,	0.50757,	0.506933,	0.502221,	0.503237,	0.502126,	0.503385],
        							[0.500801,	0.50231,	0.500126,	0.491419,	0.501778,	0.504891,	0.512924,	0.48927,	0.493859,	0.511471,	0.48993,	0.49407,	0.494063,	0.487258,	0.49063,	0.499469,	0.488774,	0.505255,	0.49976,	0.500694,	0.510764,	0.491608,	0.508869,	0.501647,	0.499744,	0.50174,	0.500911,	0.499524,	0.499112,	0.494602,	0.499407,	0.504393,	0.504237,	0.494919,	0.503951,	0.503882,	0.49138,	0.502032,	0.498492,	0.495094,	0.50011,	0.494331,	0.503843,	0.495661,	0.500467,	0.503317,	0.49987,	0.494549,	0.511311,	0.491429,	0.498953,	0.494917,	0.498677,	0.503183],
        							[0.50869,	0.496205,	0.507718,	0.497322,	0.498028,	0.49732,	0.513459,	0.496599,	0.502239,	0.500193,	0.509272,	0.504297,	0.492245,	0.495062,	0.50455,	0.504574,	0.491122,	0.497007,	0.497907,	0.495666,	0.504423,	0.493137,	0.512642,	0.49801,	0.492055,	0.499295,	0.510927,	0.504578,	0.500292,	0.492661,	0.498362,	0.496117,	0.494217,	0.499188,	0.505197,	0.496092,	0.505681,	0.508252,	0.494481,	0.492674,	0.504271,	0.507924,	0.507642,	0.503396,	0.497586,	0.51446,	0.489032,	0.490404,	0.501247,	0.494617,	0.501103,	0.498257,	0.500509,	0.502488],
        							[0.499966,	0.489304,	0.509045,	0.509935,	0.498575,	0.494488,	0.510494,	0.489768,	0.490077,	0.506013,	0.497799,	0.493318,	0.497077,	0.497311,	0.497127,	0.503172,	0.484444,	0.497985,	0.497849,	0.509814,	0.505969,	0.491379,	0.508914,	0.505332,	0.487112,	0.4981,	0.511679,	0.501863,	0.502504,	0.493369,	0.503449,	0.50173,	0.494274,	0.499354,	0.507121,	0.499234,	0.49661,	0.512585,	0.498662,	0.495307,	0.501685,	0.496533,	0.499091,	0.498745,	0.507817,	0.505426,	0.487475,	0.490307,	0.509015,	0.487564,	0.488088,	0.500618,	0.50251,	0.501622],
        							[0.496121,	0.489156,	0.511461,	0.494305,	0.503493,	0.500143,	0.508152,	0.491112,	0.496753,	0.505639,	0.48842,	0.488747,	0.488902,	0.500631,	0.503434,	0.506005,	0.485673,	0.492841,	0.497784,	0.506194,	0.502679,	0.499514,	0.503473,	0.504073,	0.496622,	0.49466,	0.50789,	0.498534,	0.50791,	0.493126,	0.499861,	0.498626,	0.504795,	0.494814,	0.508584,	0.502252,	0.492709,	0.505115,	0.499459,	0.492697,	0.50253,	0.501627,	0.495007,	0.506362,	0.503734,	0.500572,	0.488488,	0.489562,	0.497493,	0.496863,	0.487697,	0.503401,	0.494623,	0.505239],
        							[0.494232,	0.495639,	0.5118,	0.4911,	0.500942,	0.508902,	0.513487,	0.492314,	0.493142,	0.515338,	0.488809,	0.49103,	0.497618,	0.504232,	0.486676,	0.503265,	0.488957,	0.503654,	0.498164,	0.505985,	0.504316,	0.494028,	0.506321,	0.514805,	0.497046,	0.498677,	0.505532,	0.494307,	0.503401,	0.49132,	0.504334,	0.493403,	0.498377,	0.500169,	0.503907,	0.499389,	0.492957,	0.493623,	0.497079,	0.501617,	0.502033,	0.499721,	0.492455,	0.494251,	0.508219,	0.500079,	0.487728,	0.494802,	0.509797,	0.4828,	0.483474,	0.498524,	0.501835,	0.508977]
        						  ])
    
        unknown_cards0 = np.array([
                                    [0,	1,	1,	0,	1,	1,	1,	0,	1,	0,	1,	1,	0,	1,	0,	1,	0,	0,	1,	1,	0,	1,	1,	1,	0,	1,	0,	1,	1,	1,	1,	0,	1,	1,	1,	0,	1,	1,	1,	0,	1,	1,	1,	1,	1,	1,	0,	1,	1,	1,	1,	0,	0,	0],
                                    [0,	1,	0,	1,	0,	1,	0,	0,	1,	1,	0,	1,	1,	1,	1,	0,	1,	0,	1,	1,	1,	1,	0,	1,	1,	0,	0,	1,	1,	1,	1,	0,	0,	0,	1,	1,	1,	1,	1,	0,	1,	1,	1,	1,	1,	1,	1,	0,	0,	1,	1,	1,	0,	1],
                                    [1,	1,	0,	1,	1,	0,	0,	1,	0,	1,	1,	0,	1,	1,	1,	1,	1,	0,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	0,	0,	0,	0,	1,	1,	1,	0,	1,	0,	1,	1,	0,	0,	1,	0,	0,	1,	1,	0,	0,	1,	1,	1,	1,	1],
                                    [1,	1,	0,	1,	1,	0,	1,	1,	1,	1,	1,	1,	1,	0,	0,	1,	0,	1,	1,	1,	0,	1,	1,	1,	0,	1,	0,	1,	0,	1,	1,	0,	1,	1,	0,	0,	1,	1,	1,	1,	1,	1,	1,	0,	1,	0,	1,	0,	1,	0,	1,	0,	1,	0],
                                    [1,	1,	1,	1,	1,	0,	1,	1,	1,	1,	0,	1,	1,	1,	0,	1,	1,	0,	0,	1,	1,	1,	1,	0,	0,	0,	1,	0,	0,	0,	1,	0,	1,	0,	0,	0,	1,	0,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	0,	1,	0,	1,	1,	1],
                                    [0,	0,	1,	0,	0,	1,	1,	0,	1,	1,	1,	1,	1,	0,	0,	0,	0,	1,	1,	1,	0,	0,	1,	1,	1,	1,	0,	1,	1,	1,	1,	1,	0,	1,	1,	0,	1,	0,	1,	0,	1,	1,	0,	1,	1,	1,	1,	1,	0,	1,	1,	1,	1,	1],
                                    [1,	1,	0,	0,	1,	1,	1,	0,	1,	0,	1,	1,	1,	1,	0,	1,	0,	0,	1,	1,	0,	1,	0,	0,	1,	1,	0,	1,	1,	1,	1,	1,	1,	1,	1,	0,	1,	1,	0,	1,	1,	1,	0,	1,	0,	0,	1,	1,	0,	1,	1,	1,	0,	1],
                                    [1,	1,	1,	1,	0,	1,	1,	1,	1,	1,	1,	1,	1,	0,	1,	0,	1,	1,	0,	0,	1,	0,	1,	1,	0,	0,	0,	1,	1,	1,	0,	1,	0,	0,	1,	1,	1,	1,	1,	0,	1,	0,	1,	0,	0,	0,	0,	1,	1,	1,	1,	1,	1,	1],
                                    [0,	1,	0,	0,	1,	1,	0,	1,	1,	1,	1,	0,	1,	1,	1,	1,	1,	0,	0,	1,	1,	1,	1,	0,	0,	1,	0,	1,	0,	1,	1,	1,	1,	1,	0,	1,	0,	0,	1,	1,	1,	0,	1,	1,	1,	0,	1,	1,	1,	1,	1,	0,	1,	0],
                                    [1,	1,	0,	0,	1,	0,	1,	1,	1,	1,	0,	1,	0,	1,	1,	1,	1,	0,	1,	1,	1,	1,	0,	1,	0,	1,	1,	1,	0,	0,	1,	0,	1,	0,	1,	1,	1,	1,	0,	1,	1,	1,	1,	0,	0,	1,	1,	1,	0,	1,	0,	1,	1,	0]
        						  ])

    
        players_inhand_length = np.array([
        								[12,	12,	12],
        								[12,	12,	12],
        								[12,	12,	12],
        								[12,	12,	12],
        								[12,	12,	12],
        								[12,	12,	12],
        								[12,	12,	12],
        								[12,	12,	12],
        								[12,	12,	12],
        								[12,	12,	12],
        								])
    
        banker_pos = np.array([0,
                               0,
                               0,
                               0,
                               0,
                               0,
                               0,
                               0,
                               0,
                               0])
    
        state3s_batch1 = np.swapaxes(state3s_batch0, 0, 1)
        state3s_batch  = state3s_batch1[:,:,:,np.newaxis]
        guess_inhand  = np.swapaxes(guess_inhand0, 0, 1)
        guess_discard  = guess_discard0[:,np.newaxis,:]
        unknown_cards = unknown_cards0[:,np.newaxis,:]
        guess_cards = self.guess_calc(state3s_batch, guess_inhand, guess_discard, unknown_cards, copy.deepcopy(players_inhand_length), guess_env_callback)

        result_len0 = np.where(guess_cards!=0, 1, 0)
        result_len = np.sum(result_len0, axis=2)
        expected_length = np.array([12, 12, 12]*self.batch_size).reshape(self.batch_size, 3)
        results.append((result_len == expected_length).all())
        
        results.append(self.test_guess_calc_length_1(state3s_batch1, guess_inhand, guess_discard, unknown_cards, players_inhand_length, guess_env_callback))
        results.append(self.test_guess_calc_length_2(state3s_batch1, guess_inhand, guess_discard, unknown_cards, players_inhand_length, guess_env_callback))
        results.append(self.test_guess_calc_length_3(state3s_batch1, guess_inhand, guess_discard, unknown_cards, players_inhand_length, guess_env_callback))
        results.append(self.test_guess_calc_length_4(state3s_batch1, guess_inhand, guess_discard, unknown_cards, players_inhand_length, guess_env_callback))
        
        print("PlayGuess_CNN_UT::TEST_guess_calc_length(): ", results)
        return results
        


    
class Game_UT():
    def __init__(self, class_short_name):
        self.class_short_name = class_short_name

    def TEST_agent_name_etc(self):
        # to verify the class init correctness since many inheritance
        # loss(), name, fraud
        
        #                     short name,           loss,                                                  name,                              fraud
        class_name_checks ={ 'MC_q'              : ['mean_squared_error',                                 ['non-behavior'],                   5],
                             'MC_q_b'            : ['mean_squared_error',                                 ['behavior'],                       5],
                             'MC_q_sm'           : ['mean_squared_error',                                 ['non-behavior'],                   5],
                             'MC_q_avg'          : ['mean_squared_error',                                 ['non-behavior'],                   5],
                             'MC_q_g'            : ['mean_squared_error',                                 ['non-behavior', 'guess'],          4],
                             'MC_pi'             : ['categorical_crossentropy',                           ['non-behavior'],                   5],
                             'MC_pi_b'           : ['my_loss',                                            ['behavior'],                       5],
                             'MC_pi_acc'         : ['categorical_crossentropy',                           ['non-behavior', 'AC'],             5],
                             'MC_pi_acc_b'       : ['categorical_crossentropy',                           ['behavior', 'AC'],                 5],
                             'MC_pi_acc_e'       : ['categorical_crossentropy',                           ['non-behavior', 'AC'],             5],
                             'TD_q'              : ['mean_squared_error',                                 ['non-behavior', 'TD'],             5],
                             'TD_q_b'            : ['mean_squared_error',                                 ['behavior', 'TD'],                 5],
                             'MC_q_f'            : ['mean_squared_error',                                 ['non-behavior', 'fraud'],          4],
                             'MC_q_f_b'          : ['mean_squared_error',                                 ['behavior', 'fraud'],              4],
                             'MC_pi_f'           : ['categorical_crossentropy',                           ['non-behavior', 'fraud'],          4],
                             'MC_pi_f_b'         : ['my_loss',                                            ['behavior', 'fraud'],              4],
                             'MC_pi_acc_f'       : ['categorical_crossentropy',                           ['non-behavior', 'fraud', 'AC'],    4],
                             'MC_pi_acc_f_b'     : ['categorical_crossentropy',                           ['behavior', 'fraud', 'AC'],        4],
                             'MC_pi_acc_e_f'     : ['categorical_crossentropy',                           ['non-behavior', 'fraud', 'AC'],    4],
                             'C_MC_q'            : ['mean_squared_error',                                 ['non-behavior'],                   5],
                             'C_MC_q_b'          : ['mean_squared_error',                                 ['behavior'],                       5],
                             'Res_MC_q'          : ['mean_squared_error',                                 ['non-behavior'],                   5],
                             'Res_MC_q_b'        : ['mean_squared_error',                                 ['behavior'],                       5],
                             'Res_MC_pi'         : [['categorical_crossentropy', 'mean_squared_error'],   ['non-behavior'],                   5],
                             'Res_MC_pi_b'       : [['categorical_crossentropy', 'mean_squared_error'],   ['behavior'],                       5],
                             'C_MC_pi'           : [['categorical_crossentropy', 'mean_squared_error'],   ['non-behavior'],                   5],
                             'C_MC_pi_b'         : [['categorical_crossentropy', 'mean_squared_error'],   ['behavior'],                       5],
                             'Res_MC_pi_acc'     : [['categorical_crossentropy', 'mean_squared_error'],   ['non-behavior', 'AC'],             5],
                             'Res_MC_pi_acc_b'   : [['categorical_crossentropy', 'mean_squared_error'],   ['behavior', 'AC'],                 5],
                             'C_MC_q_f'          : ['mean_squared_error',                                 ['non-behavior', 'fraud'],          4],
                             'C_MC_q_f_b'        : ['mean_squared_error',                                 ['behavior', 'fraud'],              4],
                             'Res_MC_pi_f'       : [['categorical_crossentropy', 'mean_squared_error'],   ['non-behavior', 'fraud'],          4],
                             'Res_MC_pi_f_b'     : [['categorical_crossentropy', 'mean_squared_error'],   ['behavior', 'fraud'],              4],
                             'TD_q_f'            : ['mean_squared_error',                                 ['non-behavior', 'fraud', 'TD'],    4],
                             'TD_q_f_b'          : ['mean_squared_error',                                 ['behavior', 'fraud', 'TD'],        4],
                             'C_TD_q'            : ['mean_squared_error',                                 ['non-behavior', 'TD'],             5],
                             'C_TD_q_b'          : ['mean_squared_error',                                 ['behavior', 'TD'],                 5],
                             'MC_q_gd'           : ['mean_squared_error',                                 ['non-behavior', 'guess'],          4],
                             'MC_q_gd_b'         : ['mean_squared_error',                                 ['behavior', 'guess'],              4],
                             'C_MC_q_gc'         : ['mean_squared_error',                                 ['non-behavior', 'guess'],          4],
                             'C_MC_q_gc_b'       : ['mean_squared_error',                                 ['behavior', 'guess'],              4]
                             }

        check_keys = class_name_checks.keys()
        c = True
        for short_name, agent_class in self.class_short_name.items():
            print("short_name: ", short_name)
            try:
                agent = agent_class()
            except TypeError as e:
                print("TEST_agent_name_etc type error: ", e)
                print("TEST_agent_name_etc type error: ", short_name, agent_class)
                continue
            
            #not in the list at all
            if short_name not in check_keys:
                print("TEST_agent_name_etc: agent short_name not exist in chekslist: ", short_name)
                c = False
                continue

            #loss ==
            if  isinstance(agent.primay_net.loss, list):  #multiple loss(in Res_pi_xx )
                for i, loss in enumerate(agent.primay_net.loss):
                    if loss.__name__ != class_name_checks[short_name][0][i]:
                        print("TEST_agent_name_etc: agent loss MISMATCH 2: ", short_name, loss.__name__, class_name_checks[short_name][0][i])
                        c = False
            else: #single loss
                if agent.primay_net.loss.__name__ != class_name_checks[short_name][0]:
                    print("TEST_agent_name_etc: agent loss MISMATCH 1: ", short_name, agent.primay_net.loss.__name__, class_name_checks[short_name][0])
                    c = False

            #name ==
            if len(agent.name) != len(class_name_checks[short_name][1]):
                print("TEST_agent_name_etc: agent name length MISMATCH: ", short_name, agent.name, class_name_checks[short_name][1])
                c = False
            else:
                for name_item in agent.name:
                    if name_item not in class_name_checks[short_name][1]:
                        print("TEST_agent_name_etc: agent short_name not existing: ", short_name, name_item)
                        c = False
                
            #fraud ==
            if agent.fraud != class_name_checks[short_name][2]:
                print("TEST_agent_name_etc: agent fraud MISMATCH: ", short_name, agent.fraud, class_name_checks[short_name][2])
                c = False

        results = c
        print("Game_UT::TEST_agent_name_etc(): ", results)
        return results
    
class FullPokers_UT(dc.FullPokers):
    def __init__(self, game_pokers):
        #in UT instance, there is no data initialized. game_pokers host all game info
        #UT instance would be assiged as any value for test purpose
        self.game_pokers = game_pokers


class PlayAgentProxy_UT(PlayAgentProxy):
    def __init__(self, game_proxies, game_envs, game_batch_size, test_auto_level):
        #in UT instance, there is no data initialized. game_pokers host all game info
        #UT instance would be assiged as any value for test purpose
        self.game_proxies = game_proxies  #base has only 1 agent. but _UT support 4 agents
        self.game_envs = game_envs
        self.game_batch_size = game_batch_size
        self.test_auto_level = test_auto_level
    
    def test_build_decide_mask_0_leading_none(self, agent_proxy, fmt2, fmt3, envs):
        # leading selections: none
        # mine selections: meaningless
        #
        results = []
        state3s_1 = np.zeros((5,54))  #[1-4] meaningless in the target method
        state3s_3 = np.zeros((3,5,54))  #[:,1-4] meaningless in the target method
        ########################
        # batch = 1
        ########################
        # case 1
        #trump=S, round=2
        #                        0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_1[0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3, 0,    0,    0,    0,  #S
                                 fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                 0,    0,    0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                 0,    0,    fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                 fmt3, 0])                                                                 #JOKER
        state3s_batch = state3s_1
        leading_trump_batch = 0
        leading_suit_batch = dc.CardSuits.NONE

        full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
        full_mask_batch = full_mask_batch0[0] #shape: (batch, 54)
        oindex_batch = np.where(True == full_mask_batch)
        expected_batch = [3, 5, 8, 13, 14, 15, 19, 29, 35, 36, 37, 41, 45, 48, 52]
        c1 = (oindex_batch[0] == expected_batch)
        results.append(c1.all())


        ########################
        # batch = 3
        ########################
        # case 2
        #trump=S, round=2
        #                          0     1     2     3     4    5     6     7    8      9     10    11    12
        state3s_3[0,0] = np.array([0,    0,    0,    0,    0,   0,    0,    0,   0,     0,    0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,     0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,    0,    0,   0,     fmt2, fmt2, fmt2, 0,  #C
                                   0,    0,    fmt2, 0,    0,   0,    fmt2, 0,   0,     fmt2, 0,    0,    0,  #D
                                   fmt3, 0])                                                                  #JOKER
        state3s_3[1,0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3,  0,    0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,     0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,    0,    0,   0,     fmt2, fmt2, fmt2, 0,  #C
                                   0,    0,    fmt2, 0,    0,   0,    0,    0,   0,     0,    0,    0,    fmt2,  #D
                                   fmt3, 0])                                                                  #JOKER
        state3s_3[2,0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3,  0,    0,    0,    0,  #S
                                   fmt2, fmt3, 0,    0,    0,   0,    fmt2, 0,   0,     0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,    0,    0,   0,     fmt2, fmt2, fmt2, 0,  #C
                                   0,    0,    0,    0,    0,   0,    0,    0,   0,     0,    0,    0,    0,  #D
                                   0,    0])                                                                  #JOKER
        state3s_batch = state3s_3
        leading_trump_batch = [0]*3
        leading_suit_batch = [dc.CardSuits.NONE]*3

        full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
        full_mask_batch = full_mask_batch0 #shape: (batch, 54)
        oindex_batch = np.where(True == full_mask_batch)
        expected_batch = [13, 14, 15, 19, 29, 35, 36, 37, 41, 45, 48, 52,
                          3, 5, 8, 13, 14, 15, 19, 29, 35, 36, 37, 41, 51, 52,
                          3, 5, 8, 13, 14, 19, 29, 35, 36, 37]
        c2 = (oindex_batch[1] == expected_batch)
        results.append(c2.all())

        return np.array(results).all()
    
    def test_build_decide_mask_1_trump_yes(self, agent_proxy, fmt2, fmt3, envs):
        # trump=S, round=2
        # leading selections: trump=yes
        # mine selections: (C1-2)^5
        #   J: yes, no
        #   master 2: yes, no
        #   normal 2: yes, no
        #   trump suit: yes, no
        #   leading suit: yes, no
        results = []
        state3s_1 = np.zeros((5,54))  #[1-4] meaningless in the target method
        state3s_3 = np.zeros((3,5,54))  #[:,1-4] meaningless in the target method
        ########################
        # batch = 1
        ########################
        # case 3
        # fmt=3, suit=S; mine:has SPADES
        #                        0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_1[0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3, 0,    0,    0,    0,  #S
                                 fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                 0,    0,    0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                 0,    0,    fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                 fmt3, 0])                                                                 #JOKER
        state3s_batch = state3s_1
        leading_trump_batch = fmt3
        leading_suit_batch = dc.CardSuits.SPADES

        full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
        full_mask_batch = full_mask_batch0[0] #shape: (batch, 54)
        oindex_batch = np.where(True == full_mask_batch)
        expected_batch = [3, 5, 8, 14, 52]
        c1 = (oindex_batch[0] == expected_batch)
        results.append(c1.all())

        # case 4
        #fmt=3, suit=j; mine=has not SPADES
        #                        0     1     2     3     4    5    6     7    8    9     10    11    12
        state3s_1[0] = np.array([0,    0,    0,    0,    0,   0,   0,    0,   0,   0,    0,    0,    0,  #S
                                 fmt2, fmt3, fmt2, 0,    0,   0,   fmt2, 0,   0,   0,    0,    0,    0,  #H
                                 0,    0,    0,    fmt2, 0,   0,   0,    0,   0,   fmt2, fmt2, fmt2, 0,  #C
                                 0,    0,    fmt2, 0,    0,   0,   fmt2, 0,   0,   fmt2, 0,    0,    0,  #D
                                 fmt3, 0])                                                               #JOKER
        state3s_batch = state3s_1
        leading_trump_batch = fmt3
        leading_suit_batch = dc.CardSuits.REDJOKER

        full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
        full_mask_batch = full_mask_batch0[0] #shape: (batch, 54)
        oindex_batch = np.where(True == full_mask_batch)
        expected_batch = [14, 52]
        c2 = (oindex_batch[0] == expected_batch)
        results.append(c2.all())

        # case 5
        #fmt=3, suit=j; mine=has no any trump
        #                        0     1    2     3     4    5    6     7    8    9     10    11    12
        state3s_1[0] = np.array([0,    0,   0,    0,    0,   0,   0,    0,   0,   0,    0,    0,    0,  #S
                                 fmt2, 0,   fmt2, 0,    0,   0,   fmt2, 0,   0,   0,    0,    0,    0,  #H
                                 0,    0,   0,    fmt2, 0,   0,   0,    0,   0,   fmt2, fmt2, fmt2, 0,  #C
                                 0,    0,   fmt2, 0,    0,   0,   fmt2, 0,   0,   fmt2, 0,    0,    0,  #D
                                 0,    0])                                                         #JOKER
        state3s_batch = state3s_1
        leading_trump_batch = fmt3
        leading_suit_batch = dc.CardSuits.BLACKJOKER

        full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
        full_mask_batch = full_mask_batch0[0] #shape: (batch, 54)
        oindex_batch = np.where(True == full_mask_batch)
        expected_len = 10
        c3 = (len(oindex_batch[0]) == expected_len)
        results.append(c3)


        ########################
        # batch = 3
        ########################
        # case 6
        #fmt=3/3/3, suit=j/C2/S; mine=has/has/has
        #                          0     1     2     3     4    5     6     7    8      9     10    11    12
        state3s_3[0,0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3,  0,    0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,     0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,    0,    0,   0,     fmt2, fmt2, fmt2, 0,  #C
                                   0,    0,    fmt2, 0,    0,   0,    fmt2, 0,   0,     fmt2, 0,    0,    0,  #D
                                   fmt3, 0])                                                                  #JOKER
        #                          0     1     2     3     4    5     6     7    8      9     10    11    12
        state3s_3[1,0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3,  0,    0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,     0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,    0,    0,   0,     fmt2, fmt2, fmt2, 0,  #C
                                   0,    fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,     fmt2, 0,    0,    0,  #D
                                   fmt3, 0])                                                                  #JOKER
        #                          0     1     2     3     4    5     6     7    8      9     10    11    12
        state3s_3[2,0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3,  0,    0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,     0,    0,    0,    0,  #H
                                   0,    fmt3, 0,    fmt2, 0,   0,    0,    0,   0,     fmt2, fmt2, fmt2, 0,  #C
                                   0,    fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,     fmt2, 0,    0,    0,  #D
                                   fmt3, 0])                                                                  #JOKER
        state3s_batch = state3s_3
        leading_trump_batch = [fmt3, fmt3, fmt3]
        leading_suit_batch = [dc.CardSuits.REDJOKER, dc.CardSuits.CLUBS, dc.CardSuits.SPADES]

        full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
        full_mask_batch = full_mask_batch0 #shape: (batch, 54)
        oindex_batch = np.where(True == full_mask_batch)
        expected_batch = [3, 5, 8, 14, 52, 3, 5, 8, 14, 40, 52, 3, 5, 8, 14, 27, 40, 52]
        c4 = (oindex_batch[1] == expected_batch)
        results.append(c4.all())

        return np.array(results).all()
    
    def test_build_decide_mask_2_trump_no(self, agent_proxy, fmt2, fmt3, envs):
        # trump=S, round=2
        # leading selections: trump=no
        # mine selections: (C1-2)^5
        #   J: yes, no
        #   master 2: yes, no
        #   normal 2: yes, no
        #   trump suit: yes, no
        #   leading suit: yes, no
        results = []
        state3s_1 = np.zeros((5,54))  #[1-4] meaningless in the target method
        state3s_3 = np.zeros((3,5,54))  #[:,1-4] meaningless in the target method
        ########################
        # batch = 1
        ########################
        # case 7
        # fmt=2, suit=normal(H); mine=has H
        #                        0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_1[0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3, 0,    0,    0,    0,  #S
                                 fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                 0,    0,    0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                 0,    0,    fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                 fmt3, 0])                                                         #JOKER
        state3s_batch = state3s_1
        leading_trump_batch = fmt2
        leading_suit_batch = dc.CardSuits.HEARTS

        full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
        full_mask_batch = full_mask_batch0[0] #shape: (batch, 54)
        oindex_batch = np.where(True == full_mask_batch)
        expected_batch = [13, 15, 19]
        c1 = (oindex_batch[0] == expected_batch)
        results.append(c1.all())

        # case 8
        # fmt=2, suit=normal(H); mine=has not H
        #                        0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_1[0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3, 0,    0,    0,    0,  #S
                                 0,    fmt3, 0,    0,    0,   0,    0,    0,   0,    0,    0,    0,    0,  #H
                                 0,    0,    0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                 0,    0,    fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                 fmt3, 0])                                                                 #JOKER
        state3s_batch = state3s_1
        leading_trump_batch = fmt2
        leading_suit_batch = dc.CardSuits.HEARTS

        full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
        full_mask_batch = full_mask_batch0[0] #shape: (batch, 54)
        oindex_batch = np.where(True == full_mask_batch)
        expected_len = 12
        c2 = (len(oindex_batch[0]) == expected_len)
        results.append(c2)


        ########################
        # batch = 3
        ########################
        # case 9
        #fmt=2/2/2, suit=H/D/C; mine=has/has/has
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[0,0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3, 0,    0,    0,    0,  #S
                                   fmt2, 0,    fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    0,    fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   0,    0])                                                                 #JOKER
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[1,0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3, 0,    0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   0,    0])                                                                 #JOKER
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[2,0] = np.array([0,    0,    0,    0,    0,   0,    0,    0,   0,    0,    0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    fmt3, 0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   fmt3, 0])                                                                 #JOKER

        state3s_batch = state3s_3
        leading_trump_batch = [fmt2, fmt2, fmt2]
        leading_suit_batch = [dc.CardSuits.HEARTS, dc.CardSuits.DIAMONDS, dc.CardSuits.CLUBS]
        full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
        full_mask_batch = full_mask_batch0 #shape: (batch, 54)
        oindex_batch = np.where(True == full_mask_batch)
        expected_batch = [13, 15, 19, 41, 45, 48, 29, 35, 36, 37]
        c3 = (oindex_batch[1] == expected_batch)
        results.append(c3.all())

        return np.array(results).all()
    
    def test_build_decide_mask_3_trump_yes_no(self, agent_proxy, fmt2, fmt3, envs):
        # trump=S, round=2
        # leading selections: trump + non_trump mixed
        # mine selections: (C1-2)^5
        #   J: yes, no
        #   master 2: yes, no
        #   normal 2: yes, no
        #   trump suit: yes, no
        #   leading suit: yes, no
        results = []
        #state3s_1 = np.zeros((5,54))  #[1-4] meaningless in the target method
        state3s_3 = np.zeros((3,5,54))  #[:,1-4] meaningless in the target method

        ########################
        # batch = 3
        ########################
        # case 10
        # fmt=2/2/3, suit=H/C/S; mine=has/has not/has not
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[0,0] = np.array([0,    0,    0,    0,    0,   0,    0,    0,   0,    0,    0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    0,    fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   fmt3, 0])                                                                 #JOKER
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[1,0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3, 0,    0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    0,    0,   0,    0,    0,   0,    0,    0,    0,    0,  #C
                                   0,    fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   fmt3, 0])                                                                 #JOKER
        #                          0     1     2     3     4    5    6     7    8     9     10    11    12
        state3s_3[2,0] = np.array([0,    0,    0,    0,    0,   0,   0,    0,   0,    0,    0,    0,    0,  #S
                                   fmt2, 0,    fmt2, 0,    0,   0,   fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,   0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    0,    fmt2, 0,    0,   0,   fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   0,    0])                                                                #JOKER

        state3s_batch = state3s_3
        leading_trump_batch = [fmt2, fmt2, fmt3]
        leading_suit_batch = [dc.CardSuits.HEARTS, dc.CardSuits.CLUBS, dc.CardSuits.SPADES]
        full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
        full_mask_batch = full_mask_batch0 #shape: (batch, 54)
        oindex_batch = np.where(True == full_mask_batch)
        expected_batch = np.bincount(oindex_batch[0])
        c1 = (3==expected_batch[0]) and (12==expected_batch[1]) and (10==expected_batch[2])
        results.append(c1.all())


        # case 11
        # fmt=3/2/3, suit=H2/C/j; mine=has/has/has not
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[0,0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3, 0,    0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    0,    fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   fmt3, 0])                                                                 #JOKER
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[1,0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3, 0,    0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   fmt3, 0])                                                                 #JOKER
        #                          0     1     2     3     4    5    6     7    8     9     10    11    12
        state3s_3[2,0] = np.array([0,    0,    0,    0,    0,   0,   0,    0,   0,    0,    0,    0,    0,  #S
                                   fmt2, 0,    fmt2, 0,    0,   0,   fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,   0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    0,    fmt2, 0,    0,   0,   fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   0,    0])                                                                #JOKER

        state3s_batch = state3s_3
        leading_trump_batch = [fmt3, fmt2, fmt3]
        leading_suit_batch = [dc.CardSuits.HEARTS, dc.CardSuits.CLUBS, dc.CardSuits.REDJOKER]
        full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
        full_mask_batch = full_mask_batch0 #shape: (batch, 54)
        oindex_batch = np.where(True == full_mask_batch)
        expected_batch = np.bincount(oindex_batch[0])
        c2 = (5==expected_batch[0]) and (4==expected_batch[1]) and (10==expected_batch[2])
        results.append(c2)


        # case 12
        # fmt=3/3/2, suit=H2/S/C; mine=has/has/has
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[0,0] = np.array([0,    0,    0,    0,    0,   0,   0,     0,   0,    0,    0,    0,    0,  #S
                                   fmt2, 0,    fmt2, 0,    0,   0,   fmt2,  0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,   0,     0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    0,    fmt2, 0,    0,   0,   fmt2,  0,   0,    fmt2, 0,    0,    0,  #D
                                   0,    0 ])                                                                #JOKER
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[1,0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3,  0,   0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   fmt3, 0])                                                                 #JOKER
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[2,0] = np.array([0,    0,    0,    fmt3, 0,   fmt3, 0,    0,   fmt3, 0,    0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    fmt3, 0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   fmt3, 0])                                                                 #JOKER

        state3s_batch = state3s_3
        leading_trump_batch = [fmt3, fmt3, fmt2]
        leading_suit_batch = [dc.CardSuits.HEARTS, dc.CardSuits.SPADES, dc.CardSuits.CLUBS]
        full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
        full_mask_batch = full_mask_batch0 #shape: (batch, 54)
        oindex_batch = np.where(True == full_mask_batch)
        expected_batch = np.bincount(oindex_batch[0])
        c3 = (10==expected_batch[0]) and (6==expected_batch[1]) and (4==expected_batch[2])
        results.append(c3)

        # case 13
        # fmt=3/3/3, suit=H2/S/S; mine=has not/has/has
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[0,0] = np.array([fmt3, 0,    0,    0,    0,   0,   0,     0,   0,    0,    0,    fmt3, 0,  #S
                                   0,    0,    0,    0,    0,   0,   0,     0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,   0,     0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    0,    fmt2, 0,    0,   0,   fmt2,  0,   0,    fmt2, 0,    0,    0,  #D
                                   0,    0 ])                                                                #JOKER
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[1,0] = np.array([0,    fmt3, 0,    fmt3, 0,   fmt3, 0,    0,   fmt3,  0,   0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   fmt3, 0])                                                                 #JOKER
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[2,0] = np.array([0,    fmt3, 0,    0,    0,   0,    0,    0,   0,    0,    0,    0,    0,  #S
                                   fmt2, 0,    fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    0,    fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   0,    0])                                                                 #JOKER

        state3s_batch = state3s_3
        leading_trump_batch = [fmt3, fmt3, fmt3]
        leading_suit_batch = [dc.CardSuits.HEARTS, dc.CardSuits.SPADES, dc.CardSuits.SPADES]
        full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
        full_mask_batch = full_mask_batch0 #shape: (batch, 54)
        oindex_batch = np.where(True == full_mask_batch)
        expected_batch = [0, 11,
                          1, 3, 5, 8, 14, 40, 52,
                          1]
        c4 = (oindex_batch[1] == expected_batch)
        results.append(c4.all())


        # case 14
        # fmt=3/2/2, suit=j/D/C; mine=has/has/has
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[0,0] = np.array([fmt3, fmt3, 0,    0,    0,   0,   0,     0,   0,    0,    0,    fmt3, 0,  #S
                                   0,    0,    0,    0,    0,   0,   0,     0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,   0,     0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    fmt3, fmt2, 0,    0,   0,   fmt2,  0,   0,    fmt2, 0,    0,    0,  #D
                                   0,    fmt3 ])                                                             #JOKER
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[1,0] = np.array([0,    fmt3, 0,    0,    0,   0,    0,    0,   0,    0,    0,    0,    0,  #S
                                   fmt2, fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    fmt2, 0,   0,    0,    0,   0,    fmt2, fmt2, fmt2, 0,  #C
                                   0,    fmt3, fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   fmt3, 0])                                                                 #JOKER
        #                          0     1     2     3     4    5     6     7    8     9     10    11    12
        state3s_3[2,0] = np.array([0,    fmt3, 0,    fmt3, 0,   fmt3, 0,    0,   fmt3, 0,    0,    0,    0,  #S
                                   fmt2, 0,    fmt2, 0,    0,   0,    fmt2, 0,   0,    0,    0,    0,    0,  #H
                                   0,    0,    0,    0,    0,   0,    0,    0,   0,    0,    0,    0,    0,  #C
                                   0,    0,    fmt2, 0,    0,   0,    fmt2, 0,   0,    fmt2, 0,    0,    0,  #D
                                   0,    0])                                                                 #JOKER

        state3s_batch = state3s_3
        leading_trump_batch = [fmt3, fmt2, fmt2]
        leading_suit_batch = [dc.CardSuits.REDJOKER, dc.CardSuits.DIAMONDS, dc.CardSuits.CLUBS]
        full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
        full_mask_batch = full_mask_batch0 #shape: (batch, 54)
        oindex_batch = np.where(True == full_mask_batch)
        expected_batch = [0, 1, 11, 40, 53,
                          41, 45, 48,
                          1, 3, 5, 8, 13, 15, 19, 41, 45, 48]
        c5 = (oindex_batch[1] == expected_batch)
        results.append(c5.all())

        return np.array(results).all()

    def test_build_decide_mask_common1_check(self, state3s_batch, leading_trump_batch, leading_suit_batch, full_mask_batch, fmt2, fmt3, trump_suit, card_round):
        #silly alg for easy understanding
        results = []
        for state3s, leading_trump, leading_suit, full_mask in zip(state3s_batch, leading_trump_batch, leading_suit_batch, full_mask_batch):
            all_cards = (state3s > 0)
            trump_yes = (state3s == fmt3)
            trump_no = (state3s == fmt2)
            if leading_trump == fmt3:
                local_mask = trump_yes if trump_yes.any() else trump_no
            else:
                #leading is no trump
                pattern_54 = np.zeros(54)
                oindex_start = (leading_suit-1)*13
                pattern_54[oindex_start:oindex_start+13] = 1
                
                local_mask0 = trump_no[oindex_start:oindex_start+13]
                local_mask = (trump_no*pattern_54) if local_mask0.any() else all_cards
            try:
                results.append((local_mask == full_mask).all())
            except AttributeError as e: #'bool' object has no attribute 'all'
                results.append(False)
                print(e)
                print(state3s)
                print(leading_trump, leading_suit)
                print(full_mask)
                print(fmt2, fmt3, trump_suit, card_round)

        return np.array(results)
    
    def test_build_decide_mask_massive(self, agent_proxy, fmt2, fmt3, envs):
        #xx_auto() will not take long time(400k+ loop). skip xx_massive()
        result = self.test_build_decide_mask_auto(agent_proxy, fmt2, fmt3, envs)
        return result
    
    def test_build_decide_mask_auto(self, agent_proxy, fmt2, fmt3, envs):
        # state3s INPUT:
        #   trump loop: S, H, C, D
        #   round loop: 0~12
        #   suit actions: has suit or not; has 2 or not
        # leading: 5 classes
        state3s_1 = np.zeros((5,54))  #[:,1-4] meaningless in the target method
        counter_leading = 0
        gcnt = 0
        leading_trump_batch = []
        leading_suit_batch = []
        results = []
        
        for trump in [dc.CardSuits.SPADES, dc.CardSuits.HEARTS, dc.CardSuits.CLUBS, dc.CardSuits.DIAMONDS]:
            for card_round in range(13):
                for has_suit_2s in range(16): # bitmap: 0000~1(D)111(S), 对应suit_oindexs loop中的每一个suit
                    for has_suits in range(1, 64): # bitmap: 000001(S) ~ 1(RJ)11(D)111, 对应suit_oindexs loop中的每一个suit. must have one suit
                        for suit, suit_oindexs in [[dc.CardSuits.SPADES,range(0,13)], [dc.CardSuits.HEARTS, range(13,26)], [dc.CardSuits.CLUBS, range(26,39)], [dc.CardSuits.DIAMONDS, range(39,52)], [dc.CardSuits.BLACKJOKER, [52]], [dc.CardSuits.REDJOKER, [53]]]: #, , , , , :
                            # state3. TBD: optm!?
                            has_suit = (has_suits & (1<<(suit-1)) > 0)
                            if suit in [dc.CardSuits.BLACKJOKER, dc.CardSuits.REDJOKER]:
                                fmt = fmt3
                                has_suit_2 = False
                                oindex_selected = suit_oindexs
                            else:
                                low = 2
                                high = 13
                                if trump == suit:
                                    fmt = fmt3
                                else:
                                    fmt = fmt2
                                has_suit_2 = ((has_suit_2s & (1<<(suit-1))) > 0)
                                oindex_selected = np.random.choice(suit_oindexs, size=np.random.randint(low,high), replace=False)
                                
                            if True == has_suit :
                                state3s_1[0, oindex_selected] = fmt
                            if True == has_suit_2: 
                                state3s_1[0, suit_oindexs[card_round]] = fmt3
                            elif suit not in [dc.CardSuits.BLACKJOKER, dc.CardSuits.REDJOKER]:
                                #is case it was set in oindex_selected
                                state3s_1[0, suit_oindexs[card_round]] = 0 #since randint(2), so at least, there is 1 casd left
                        pass #loop  'suit, suit_oindexs'
                        
                        #all suits run out once, state3s_1 is ready
                        state3s_batch = state3s_1.reshape(-1)[np.newaxis,:].repeat(9, axis=0).reshape(9, 5, 54)

                        non_trump = [dc.CardSuits.SPADES, dc.CardSuits.HEARTS, dc.CardSuits.CLUBS, dc.CardSuits.DIAMONDS]
                        non_trump.remove(trump)
                        
                        #class 1~5 as leading selections of INPUT data. ignore the NONE
                        for fmt, suits in [[fmt3, [trump]], [fmt3, non_trump], [fmt3, [dc.CardSuits.BLACKJOKER]], [fmt3, [dc.CardSuits.REDJOKER]], [fmt2, non_trump]]:
                            #total counts in this loop = 9. with same state3
                            for suit in suits:
                                leading_trump_batch.append(fmt)
                                leading_suit_batch.append(suit)
                                if 8 <= counter_leading:
                                    full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
                                    results0 = self.test_build_decide_mask_common1_check(state3s_batch[:,0], leading_trump_batch, leading_suit_batch, full_mask_batch0, fmt2, fmt3, trump, card_round)
                                    if not results0.all():
                                        print("comparison error")
                                        for i, result in enumerate(results0):
                                            if not result:
                                                print(i)
                                                print(state3s_batch[i,0])
                                                print(leading_trump_batch[i], leading_suit_batch[i])
                                                print(full_mask_batch0[i], fmt2, fmt3, trump, card_round)
                                                
                                    counter_leading = 0
                                    leading_trump_batch = []
                                    leading_suit_batch = []
                                    results.append(results0)
                                else:
                                    counter_leading += 1

                                gcnt += 1
                                if gcnt % 10000 == 0:
                                    print(".", end='')
                                if gcnt % 100000 == 0:
                                    print(gcnt, end='')

                        #the remaining counter_leading个inputs
                        if counter_leading > 0:
                            print("counter_leading > 0")
                            '''
                            state3s_batch = state3s_batch[:counter_leading]
                            full_mask_batch0, _, _ = agent_proxy.build_decide_mask(envs, state3s_batch, leading_trump_batch, leading_suit_batch)
                            full_mask_batch = full_mask_batch0 #shape: (batch, 54)
                            oindex_batch = np.where(True == full_mask_batch)
                            expected_batch = [0, 1, 11, 40, 53,
                                              41, 45, 48,
                                              1, 3, 5, 8, 13, 15, 19, 41, 45, 48]
                            c5 = (oindex_batch[1] == expected_batch)
                            results.append(c5.all())
                            counter_leading = 0
                            '''
                        state3s_1 = np.zeros((5,54))
                    
                    pass #suit_2s
                                
        return np.array(results).all()
    
    def TEST_build_decide_mask(self):
        ######################################
        # base DATA preparation: 
        #   NO global data impacted
        #   NO env, proxy, full_poker object imapced
        ######################################
        # base INPUT preparation: 
        #   envs
        #   state3s_batch
        #   leading_trump_batch
        #   leading_suit_batch
        # assume: trump=S, round=2. all fmt2/fm3 assignment aglin to trump=S, round=2
        #
        # input batch size: 1, >1
        # leading selections: 1.none; 2.trump(master 2 or suit); 3.trump(nomral 2); 4.trump(J); 5.nomral suit. C1-5
        # mine selections: (C1-2)^6
        #   a: J: yes, no
        #   b: master 2: yes, no
        #   c: normal 2: yes, no
        #   d: trump suit: yes, no
        #   e: leading suit: yes, no
        #   f: normal suit has 2: yes, no
        #
        # CASEs distribution
        # ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        # |       |      a=Y       |    a=N    |   b=Y   |       b=N       |       c=Y       |   c=N   |      d=Y     |     d=N     |      e=Y       |    e=N    |     f=Y    |    f=N    |
        # ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        # |   1   |  ... case 1/2  ...                                                                                                                                                    |
        # ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        # |   2   | 3/6c/12b/13b   | 10c/13c   | 13b/13c | 3/6c/10c/12b    | 3/6c/12b/13b    | 10c/13c | 3/6c/12b/13b  | 10c/13c    | 3/6c/12b/13b   | 10c/13c   | NA         | NA        |
        # ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        # |   3   | 6b/11a         | 12a/13a   | 13a     | 6b/11a/12a/13a  | 6b/11a          | 12a/13a | 6b/11a/13a    | 12a        | 6b/11a/12a     | 13a       | 6b/11a     | 12a/13a   |
        # ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        # |   4   | 4/6a/14a       | 5/11c     | 14a     | 4/5/6a/11c      | 4/6a/14a        | 5/11c   | 6a/14a        | 4/5/11c    | NA             | NA        | NA         | NA        |
        # ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        # |   5   | 7/8/9c/10a/10b | 9a/9b/14c | 14b/14c | 7/8/9a/9b/9c/   | 7/8/9b/9c/10a/  | 9a/14c  | 7/8/9a/9b/10b | 9c/10a/14b | 7/9a/9b/9c/10a | 8/10b/14c | 7/8/9b/10a | 9a/9c/10b |
        # |       | /11b/12c/14b   |           |         | 10a/10b/11b/12c | 10b/11b/12c/14b |         | /11b/12c/14c  |            | /11b/12c/14b   |           | /12c/14b   | /11b/14c  |
        # ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        agent_proxy = self.game_proxies[dc.Players.SOUTH] #whatever a real agent. just test the full_mask
        fmt2 = self.game_envs.net_input_format[2]
        fmt3 = self.game_envs.net_input_format[3]
        envs = self.game_envs

        results = []
        # run sub testcase:
        results.append(self.test_build_decide_mask_0_leading_none(agent_proxy, fmt2, fmt3, envs))
        results.append(self.test_build_decide_mask_1_trump_yes(agent_proxy, fmt2, fmt3, envs))
        results.append(self.test_build_decide_mask_2_trump_no(agent_proxy, fmt2, fmt3, envs))
        results.append(self.test_build_decide_mask_3_trump_yes_no(agent_proxy, fmt2, fmt3, envs))
        
        if self.test_auto_level > 0 :
            results.append(self.test_build_decide_mask_massive(agent_proxy, fmt2, fmt3, envs))
            print("\n")
            if self.test_auto_level > 1:
                results.append(self.test_build_decide_mask_auto(agent_proxy, fmt2, fmt3, envs))
                print("\n")
                
        result = np.array(results).all()
        print("PokerEnvironment_6_1::build_decide_mask(): ", result, results)
        return results 
        
                  
        
class PokerEnvironment_6_1_UT(PokerEnvironment_6_1):
    def __init__(self, game_envs, test_auto_level):
        super().__init__(n=game_envs.n)
        #in UT instance, there is no data initialized. game_envs host all game info(so far, it is alse not data from Game54() yet
        #data in UT instance would be assiged as any value for test purpose
        self.game_envs = game_envs
        self.test_auto_level = test_auto_level
    
    def assign_total_weights(self, trump_suit=dc.CardSuits.SPADES, card_round=2):
        #MUST be based off: trump=S, round=2 as default
        #trump/round are same in every cardset. worse than real env.
        '''
        weights = [39,	42,	28,	29,	30,	31,	32,	33,	34,	35,	36,	37,	38,	
                   13,	40,	2,	3,	4,	5,	6,	7,	8,	9,	10,	11,	12,	
                   13,	40,	2,	3,	4,	5,	6,	7,	8,	9,	10,	11,	12,	
                   13,	40,	2,	3,	4,	5,	6,	7,	8,	9,	10,	11,	12,	
                   43,	44]
        '''
        np_weights = np.array([13,	1,	2,	3,	4,	5,	6,	7,	8,	9,	10,	11,	12,	
                               13,	1,	2,	3,	4,	5,	6,	7,	8,	9,	10,	11,	12,	
                               13,	1,	2,	3,	4,	5,	6,	7,	8,	9,	10,	11,	12,	
                               13,	1,	2,	3,	4,	5,	6,	7,	8,	9,	10,	11,	12,	
                               43,	44])
        
        suit_index = np.where(self.players[0:4] == trump_suit)[0][0]
        np_weights[suit_index*13:(suit_index+1)*13] += 26
        np_weights[[0+card_round-1, 13+card_round-1, 26+card_round-1, 39+card_round-1]] = 40
        np_weights[suit_index*13 + card_round-1] = 42
        
        self.total_weights = np_weights[np.newaxis,:].repeat(self.n, axis=0)
    
    def assign_full_poker_np_cards(self):
        self.full_poker.np_cards = np.array([dc.cards_T]*self.n)
    
    def assign_full_poker_np_trumps(self, suit=[dc.CardSuits.SPADES]):
        if 1 == len(suit):
            self.full_poker.np_trumps = np.array(suit*self.n)
        else:
            self.full_poker.np_trumps = suit
            
    def assign_full_poker_np_bankers(self, banker=[dc.Players.SOUTH]):#MUST from SOUTH
        #only support 'all bankers are same' @shuffle_cards()
        if 1 == len(banker):
            self.full_poker.np_bankers = np.array(banker*self.n)
        else:
            self.full_poker.np_bankers = banker

    def assign_full_poker_np_rounds(self, card_round=[2]): #disacrd will not discard 2 since importancy is bigger
        if 1 == len(card_round):
            self.full_poker.np_rounds = np.array(card_round*self.n)
        else:
            self.full_poker.np_rounds = card_round

    def shuffle_and_deal_cards(self):#same to shuffle_and_deal_cards2() with seed=7307
        self.full_poker.np_cards = cards_7307.reshape(1,-1).repeat(self.n, axis=0).reshape(self.n, 54, dc.COL_END)
        #self.full_poker.render([0]) #cardset = 0
        
    def shuffle_and_deal_cards2(self, seed=7307):
        np.random.seed(seed) #cards_7307[] is generated by seed=7307

        #all cardsets keep same shuffle and assigned 'who'. easier in testing
        cards_54 = np.arange(54)
        first_player_pos = np.where(self.players == self.full_poker.np_bankers[0]) #all bankers are same
        players_seq = self.players[first_player_pos[0][0]:first_player_pos[0][0]+4]
        
        shuffle_index_0 = np.random.choice(cards_54, size=18, replace=False)
        cards_36 = list(set(cards_54) - set(shuffle_index_0))
        shuffle_index_1 = np.random.choice(cards_36, size=12, replace=False)
        cards_24 = list(set(cards_36) - set(shuffle_index_1))
        shuffle_index_2 = np.random.choice(cards_24, size=12, replace=False)
        shuffle_index_3 = np.array(list(set(cards_24) - set(shuffle_index_2)))
        
        who = self.full_poker.np_cards[:,:,dc.COL_WHO]
        who[:, shuffle_index_0] = players_seq[0]
        who[:, shuffle_index_1] = players_seq[1]
        who[:, shuffle_index_2] = players_seq[2]
        who[:, shuffle_index_3] = players_seq[3]
        #need not sort. it is already ordered
        #self.full_poker.render([0]) #cardset = 0

    def discard_cards(self): #based off card_7307[]
        #D5/7/9=43,45,47, C10=35, H4/5=16,17
        discarding = self.full_poker.np_cards[:,:,dc.COL_DISCARDED]
        discarding[:, np.s_[16, 17, 35, 43, 45, 47]] = True
        #self.full_poker.render([0]) #cardset = 0

    def discard_cards2(self): #random discard for testing test_step_play_1card_massive()
        #ignre the env.reset(0 for best_discard_oindex
        discarding = self.full_poker.np_cards[:,:,dc.COL_DISCARDED]
        south_oindex = self.full_poker.np_cards[self.full_poker.np_cards[:,:,dc.COL_WHO]==dc.Players.SOUTH, dc.COL_OINDEX].reshape(self.n, 18)
        for i in range(self.n):
            seleced_oindex = np.random.choice(south_oindex[i], size=6, replace=False)
            discarding[i, np.s_[seleced_oindex]] = True
        #self.full_poker.render([0,self.n-1]) #cardset = 0

    def TEST_init_all_player_cards(self):
        print("PokerEnvironment_6_1::init_all_player_cards() TBD")
        
    def TEST_sum_cards_importancy(self):
        print("PokerEnvironment_6_1::sum_cards_importancy() TBD")

    def TEST_assign_discard_prority_to_card(self):
        print("PokerEnvironment_6_1::assign_discard_prority_to_card() TBD")
        
    def TEST_calc_deviation(self):
        print("PokerEnvironment_6_1::calc_deviation() TBD")
        
    def TEST_create_AKQJ_pattern(self):
        print("PokerEnvironment_6_1::create_AKQJ_pattern() TBD")

    def test_round_rewards_0(self, round_winners, player_sequences, scores_got):
        rewards = self.round_rewards(round_winners, player_sequences, scores_got)
        expected_result_800 = np.array([ [ 0.2, -0.2,   0.2, -0.2],
                                         [-0.1,  0.1,  -0.1,  0.1],
                                         [ 0.5, -0.5,   0.5, -0.5],
                                         [-0.4,  0.4,  -0.4,  0.4],
                                         [-0.3,  0.3,  -0.3,  0.3],
                                         [ 0.1, -0.1,   0.1, -0.1],
                                         [ 0.5, -0.5,   0.5, -0.5],
                                         [-0.5,  0.5,  -0.5,  0.5] ])

        expected_result_801 = np.zeros((8,4))

        expected_result_802 = np.array([[ 0.2, -0.2,  0.2, -0.2],
                                        [-0.1,  0.1, -0.1,  0.1],
                                        [ 0.1, -0.1,  0.1, -0.1],
                                        [-0.4,  0.4, -0.4,  0.4],
                                        [-0.3,  0.3, -0.3,  0.3],
                                        [ 0.1, -0.1,  0.1, -0.1],
                                        [ 0.1, -0.1,  0.1, -0.1],
                                        [-0.5,  0.5, -0.5,  0.5] ])

        if self.game_envs.play_reward_template == [-1, 0.5, 1, 2]:
            expected_result = expected_result_800
        elif self.game_envs.play_reward_template == [ 0, 0, 0, 1]:
            expected_result = expected_result_801
        elif self.game_envs.play_reward_template == [-1, 0.1, 1, 1]:
            expected_result = expected_result_802
        else:
            expected_result = np.full((8,4), float('nan'))  #MUST fail. unsupported reward config

        c = (rewards == expected_result)
        return c.all()

    def test_round_rewards_1(self, round_winners, player_sequences, scores_got):
        self.play_reward_template = [-1, 1, 2, 5]
        rewards = self.round_rewards(round_winners, player_sequences, scores_got)
        expected_result = np.array([[  0.4, -0.4,  0.4, -0.4],
                                    [ -0.2,  0.2, -0.2,  0.2],
                                    [  1.0, -1.0,  1.0, -1.0],
                                    [ -0.8,  0.8, -0.8,  0.8],
                                    [ -0.6,  0.6, -0.6,  0.6],
                                    [  0.2, -0.2,  0.2, -0.2],
                                    [  1.0, -1.0,  1.0, -1.0],
                                    [ -1.0,  1.0, -1.0,  1.0]])


        c = (rewards == expected_result)
        return c.all()

    def TEST_round_rewards(self):
        ######################################
        # base DATA preparation: 
        #   env.play_reward_template[], read from game.env from config
        #   meas object: it is default ready in env_xx.py. need not allocate new one
        ######################################
        self.play_reward_template = self.game_envs.play_reward_template
        #print(self.play_reward_template)

        ######################################
        # base INPUT preparation: 
        #   NOTE: cardsets != self.n
        round_winners = np.array([dc.Players.NORTH,  dc.Players.WEST, 
                                  dc.Players.EAST,   dc.Players.WEST,
                                  dc.Players.SOUTH,  dc.Players.WEST, 
                                  dc.Players.SOUTH,  dc.Players.SOUTH])
        player_sequences = np.array([ [dc.Players.SOUTH, dc.Players.EAST,  dc.Players.NORTH, dc.Players.WEST],
                                      [dc.Players.NORTH, dc.Players.WEST,  dc.Players.SOUTH, dc.Players.EAST],
                                      [dc.Players.EAST,  dc.Players.NORTH, dc.Players.WEST,  dc.Players.SOUTH],
                                      [dc.Players.SOUTH, dc.Players.EAST,  dc.Players.NORTH, dc.Players.WEST],
                                      [dc.Players.WEST,  dc.Players.SOUTH, dc.Players.EAST,  dc.Players.NORTH],
                                      [dc.Players.WEST,  dc.Players.SOUTH, dc.Players.EAST,  dc.Players.NORTH],
                                      [dc.Players.NORTH, dc.Players.WEST,  dc.Players.SOUTH, dc.Players.EAST],
                                      [dc.Players.EAST,  dc.Players.NORTH, dc.Players.WEST,  dc.Players.SOUTH] ])
        scores_got = np.array([10, 5, 0, 20, 15, 5, 0, 25])

        results = []
        # run sub testcase:
        results.append(self.test_round_rewards_0(round_winners, player_sequences, scores_got))
        results.append(self.test_round_rewards_1(round_winners, player_sequences, scores_got))
        #static case is enought to cover all checkpoints!        
                
        result = np.array(results).all()
        print("PokerEnvironment_6_1::round_rewards() ", result, results)

    def test_game_result_0_banker_sn_win(self, last_round_winners, scores):
        ######################################
        # base INPUT: default INPUT
        winners, level_raised, scores_sn, scores_ew = self.game_result(last_round_winners, scores)
        
        expected_winners = np.array([ [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ] ])
        expected_level_raised = np.array([3, 2, 1, 1, 1, 0, 0, 1, 1, 2])
        expected_score_sn = np.array([100, 95, 80, 70, 65, 60, 45, 40, 35, 20])
        expected_score_ew = np.array([0, 5, 20, 30, 35, 40, 55, 60, 65, 80])
        c1 = (expected_winners == winners)
        c2 = (expected_level_raised == level_raised)
        c3 = (expected_score_sn == scores_sn)
        c4 = (expected_score_ew == scores_ew)
        c = c1.all() and c2.all() and c3.all() and c4.all()
        
        ######################################
        # base INPUT variant: 
        #   
        scores = np.array([ [70,	0 ,	0 ,	10],
                            [50,	10,	15,	5 ],
                            [0 ,	0 ,	60,	20],
                            [55,	15,	0 ,	10],
                            [10,	20,	30,	20],
                            [0 ,	0 ,	35,	45],
                            [5 ,	40,	15,	20],
                            [0 ,	70,	5 ,	5 ],
                            [5 ,	0 ,	5 ,	70],
                            [0 ,	5 ,	0 ,	75] ])

        last_round_winners = np.array([dc.Players.SOUTH,  dc.Players.NORTH,   #banker win
                                       dc.Players.NORTH,  dc.Players.NORTH,
                                       dc.Players.SOUTH,  dc.Players.SOUTH,
                                       dc.Players.NORTH,  dc.Players.SOUTH, 
                                       dc.Players.NORTH,  dc.Players.NORTH])

        winners, level_raised, scores_sn, scores_ew = self.game_result(last_round_winners, scores)
        expected_winners = np.array([ [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ] ])
        expected_level_raised = np.array([2, 2, 1, 1, 0, 0, 1, 1, 1, 2])
        expected_score_sn = np.array([90, 85, 80, 75, 60, 55, 40, 25, 30, 20])
        expected_score_ew = np.array([10, 15, 20, 25, 40, 45, 60, 75, 70, 80])
        c5 = (expected_winners == winners)
        c6 = (expected_level_raised == level_raised)
        c7 = (expected_score_sn == scores_sn)
        c8 = (expected_score_ew == scores_ew)
        c = c1.all() and c2.all() and c3.all() and c4.all() and c5.all() and \
            c6.all() and c7.all() and c8.all()

        return c

    def test_game_result_1_banker_sn_loss(self, last_round_winners, scores):
        ######################################
        # base INPUT: recover default INPUT
        scores = np.array([ [20,	0 ,	60,	0 ],    #start from S=0. 0~80 as discarded=20
                            [75,	5 ,	0 ,	0 ],
                            [30,	15,	30,	5 ],
                            [5 ,	30,	45,	0 ],
                            [40,	10,	5 ,	25],
                            [25,	40,	15,	0 ],
                            [5 ,	50,	20,	5 ],
                            [20,	0 ,	0 ,	60],
                            [10,	65,	5 ,	0 ],
                            [0 ,	80,	0 ,	0 ] ])
        last_round_winners = np.array([dc.Players.EAST,  dc.Players.EAST,   #banker loss
                                       dc.Players.WEST,  dc.Players.WEST,
                                       dc.Players.EAST,  dc.Players.EAST,
                                       dc.Players.WEST,  dc.Players.WEST, 
                                       dc.Players.WEST,  dc.Players.EAST])
        winners, level_raised, scores_sn, scores_ew = self.game_result(last_round_winners, scores)
        
        expected_winners = np.array([ [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ] ])
        expected_level_raised = np.array([1, 1, 0, 0, 0, 1, 1, 2, 2, 3])
        expected_score_sn = np.array([80, 75, 60, 50, 45, 40, 25, 20, 15, 0])
        expected_score_ew = np.array([20, 25, 40, 50, 55, 60, 75, 80, 85, 100])
        c1 = (expected_winners == winners)
        c2 = (expected_level_raised == level_raised)
        c3 = (expected_score_sn == scores_sn)
        c4 = (expected_score_ew == scores_ew)
        c = c1.all() and c2.all() and c3.all() and c4.all()
        
        ######################################
        # base INPUT variant: 
        #   
        scores = np.array([ [70,	0 ,	0 ,	10],
                            [50,	10,	15,	5 ],
                            [0 ,	0 ,	60,	20],
                            [55,	15,	0 ,	10],
                            [10,	20,	30,	20],
                            [0 ,	0 ,	35,	45],
                            [5 ,	40,	15,	20],
                            [0 ,	70,	5 ,	5 ],
                            [5 ,	0 ,	5 ,	70],
                            [0 ,	5 ,	0 ,	75] ])

        last_round_winners = np.array([dc.Players.WEST,  dc.Players.EAST,   #banker win
                                       dc.Players.EAST,  dc.Players.EAST,
                                       dc.Players.WEST,  dc.Players.EAST,
                                       dc.Players.EAST,  dc.Players.WEST, 
                                       dc.Players.EAST,  dc.Players.WEST])

        winners, level_raised, scores_sn, scores_ew = self.game_result(last_round_winners, scores)
        expected_winners = np.array([ [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ] ])
        expected_level_raised = np.array([1, 1, 0, 0, 1, 1, 2, 2, 2, 3])
        expected_score_sn = np.array([70, 65, 60, 55, 40, 35, 20, 5, 10, 0])
        expected_score_ew = np.array([30, 35, 40, 45, 60, 65, 80, 95, 90, 100])
        c5 = (expected_winners == winners)
        c6 = (expected_level_raised == level_raised)
        c7 = (expected_score_sn == scores_sn)
        c8 = (expected_score_ew == scores_ew)
        c = c1.all() and c2.all() and c3.all() and c4.all() and c5.all() and \
            c6.all() and c7.all() and c8.all()

        return c

    def test_game_result_2_banker_ew(self, last_round_winners, scores):
        ######################################
        # base DATA : variant
        #   self.full_poker.np_bankers. env only support SOUTH. but in UT would be any
        bankers = np.array([dc.Players.WEST,  dc.Players.WEST, dc.Players.EAST,  dc.Players.EAST, dc.Players.EAST,  
                            dc.Players.WEST,  dc.Players.EAST, dc.Players.EAST,  dc.Players.WEST, dc.Players.WEST])
        self.assign_full_poker_np_bankers(bankers)  #env only support. but UT can varied
        
        ######################################
        # base INPUT: recover default INPUT
        scores = np.array([ [20,	0 ,	60,	0 ],    #start from S=0. 0~80 as discarded=20
                            [75,	5 ,	0 ,	0 ],
                            [30,	15,	30,	5 ],
                            [5 ,	30,	45,	0 ],
                            [40,	10,	5 ,	25],
                            [25,	40,	15,	0 ],
                            [5 ,	50,	20,	5 ],
                            [20,	0 ,	0 ,	60],
                            [10,	65,	5 ,	0 ],
                            [0 ,	80,	0 ,	0 ] ])
        last_round_winners = np.array([dc.Players.SOUTH,  dc.Players.NORTH,   #non-banker win
                                       dc.Players.NORTH,  dc.Players.NORTH,
                                       dc.Players.SOUTH,  dc.Players.SOUTH,
                                       dc.Players.NORTH,  dc.Players.SOUTH, 
                                       dc.Players.NORTH,  dc.Players.NORTH])
        winners, level_raised, scores_sn, scores_ew = self.game_result(last_round_winners, scores)
        
        expected_winners = np.array([ [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ] ])
        expected_level_raised = np.array([3, 2, 2, 1, 1, 1, 0, 0, 1, 1])
        expected_score_sn = np.array([100, 95, 80, 70, 65, 60, 45, 40, 35, 20])
        expected_score_ew = np.array([0, 5, 20, 30, 35, 40, 55, 60, 65, 80])
        c1 = (expected_winners == winners)
        c2 = (expected_level_raised == level_raised)
        c3 = (expected_score_sn == scores_sn)
        c4 = (expected_score_ew == scores_ew)
        c = c1.all() and c2.all() and c3.all() and c4.all()
        
        ######################################
        # base INPUT variant: as default
        #
        last_round_winners = np.array([dc.Players.WEST,  dc.Players.EAST,   #banker win
                                       dc.Players.EAST,  dc.Players.EAST,
                                       dc.Players.WEST,  dc.Players.EAST,
                                       dc.Players.EAST,  dc.Players.WEST, 
                                       dc.Players.EAST,  dc.Players.WEST])

        winners, level_raised, scores_sn, scores_ew = self.game_result(last_round_winners, scores)
        expected_winners = np.array([ [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.SOUTH, dc.Players.NORTH],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ],
                                      [dc.Players.EAST,  dc.Players.WEST ] ])
        expected_level_raised = np.array([2, 1, 1, 0, 0, 0, 1, 1, 2, 3])
        expected_score_sn = np.array([80, 75, 60, 50, 45, 40, 25, 20, 15, 0])
        expected_score_ew = np.array([20, 25, 40, 50, 55, 60, 75, 80, 85, 100])
        c5 = (expected_winners == winners)
        c6 = (expected_level_raised == level_raised)
        c7 = (expected_score_sn == scores_sn)
        c8 = (expected_score_ew == scores_ew)
        c = c1.all() and c2.all() and c3.all() and c4.all() and c5.all() and \
            c6.all() and c7.all() and c8.all()

        return c

        
    def TEST_game_result(self):
        ######################################
        # base DATA preparation: 
        #   self.full_poker.np_cards[:,:,dc.COL_DISCARDED]
        #   self.full_poker.np_cards[:,:,dc.COL_SCORE]
        #   self.full_poker.np_bankers. env only support SOUTH. but in UT is would be any
        #   meas object: it is default ready in env_xx.py. need not allocate new one
        ######################################
        self.assign_full_poker_np_bankers()  #only support 'all bankers are same' @shuffle_cards()
        self.shuffle_and_deal_cards() #need not sorting
        #self.discard_cards() #need not, card_7307 includes 'discard'

        ######################################
        # base INPUT preparation: 
        #   NOTE: cardsets != self.n
        last_round_winners = np.array([dc.Players.NORTH,  dc.Players.SOUTH,   #banker win
                                       dc.Players.NORTH,  dc.Players.NORTH,
                                       dc.Players.NORTH,  dc.Players.NORTH,
                                       dc.Players.SOUTH,  dc.Players.SOUTH, 
                                       dc.Players.SOUTH,  dc.Players.SOUTH])
        scores = np.array([ [20,	0 ,	60,	0 ],    #start from S=0. 0~80 as discarded=20
                            [75,	5 ,	0 ,	0 ],
                            [30,	15,	30,	5 ],
                            [5 ,	30,	45,	0 ],
                            [40,	10,	5 ,	25],
                            [25,	40,	15,	0 ],
                            [5 ,	50,	20,	5 ],
                            [20,	0 ,	0 ,	60],
                            [10,	65,	5 ,	0 ],
                            [0 ,	80,	0 ,	0 ] ])
        results = []
        # run sub testcase:
        results.append(self.test_game_result_0_banker_sn_win(last_round_winners, scores))
        results.append(self.test_game_result_1_banker_sn_loss(last_round_winners, scores))
        results.append(self.test_game_result_2_banker_ew(last_round_winners, scores))
        #static case is enought to cover all checkpoints!        
                
        result = np.array(results).all()
        print("PokerEnvironment_6_1::game_result() ", result, results)
        
    def TEST_create_best_discards(self):
        print("PokerEnvironment_6_1::create_best_discards() TBD")
    
    def test_collect_card_last_round_common_1_DATA(self, config=1):
        s_full_played = self.full_poker.np_cards[:, :, dc.COL_PLAYED]
        s_full_discarded = self.full_poker.np_cards[:, :, dc.COL_DISCARDED]
        #s_full_who = self.full_poker.np_cards[:, :, dc.COL_WHO]
        s_full_oindex = self.full_poker.np_cards[:, :, dc.COL_OINDEX]
                                         #S     E     N     W
        senw_cards_template = np.array([ [0 ,   2 ,   6 ,   1 ],   #oindex, every player has 1 card
                                         [3 ,   7 ,   10,   5 ],
                                         [4 ,   11,   12,   9 ],
                                         [8 ,   27,   13,   15],
                                         [14,   28,   19,   20],
                                         [18,   33,   25,   29],
                                         [21,   42,   30,   31],
                                         [22,   44,   37,   32],
                                         [23,   46,   39,   34],
                                         [24,   49,   41,   36],
                                         [26,   51,   50,   40],
                                         [38,   52,   53,   48] ])
        if 1 == config:
            last_round_played_oindex = senw_cards_template[:self.n]
        elif 2 == config:
            np.random.shuffle(senw_cards_template[:,0])
            np.random.shuffle(senw_cards_template[:,1])
            np.random.shuffle(senw_cards_template[:,2])
            np.random.shuffle(senw_cards_template[:,3])
            senw_cards_selected = np.random.choice(np.arange(12), size=10, replace=False)
            last_round_played_oindex = senw_cards_template[senw_cards_selected]
            
        avail_cards_index = np.logical_not(s_full_discarded) #not play yet, it is right
        s_full_played[avail_cards_index] = True  #default as played, later will remove 4 cards
        for i, (oindex, played_oindex) in enumerate(zip(s_full_oindex, last_round_played_oindex)):
            oindex_4 = oindex[np.newaxis, :].repeat(4, axis=0)
            avail_pos = np.where(oindex_4 == played_oindex[:,np.newaxis])  #search 4 'played'
            s_full_played[i, avail_pos[1]] = False  #clear poker.np_cards[]

        return last_round_played_oindex
    
    def test_collect_card_last_round_0(self, last_winners) : #, last_round_played_oindex):
        ######################################
        # base DATA: default
        ######################################
        # base INPUT: default
        
        last_round_cards = self.collect_card_last_round(last_winners)
                                               #1st   2nd   3rd   4th
        expected_last_round_oindex = np.array([ [6 ,   1,    0 ,   2 ],   #oindex, every player has 1 card
                                                [5,    3 ,   7 ,   10],
                                                [9,    4 ,   11,   12],
                                                [27,   13,   15,    8],
                                                [20,   14,   28,   19],
                                                [25,   29,   18,   33],
                                                [21,   42,   30,   31],
                                                [44,   37,   32,   22],
                                                [23,   46,   39,   34],
                                                [49,   41,   36,   24] ])
        expected_last_round_who = np.array([ [dc.Players.NORTH, dc.Players.WEST,  dc.Players.SOUTH, dc.Players.EAST  ],
                                             [dc.Players.WEST,  dc.Players.SOUTH, dc.Players.EAST,  dc.Players.NORTH ],
                                             [dc.Players.WEST,  dc.Players.SOUTH, dc.Players.EAST,  dc.Players.NORTH ],
                                             [dc.Players.EAST,  dc.Players.NORTH, dc.Players.WEST,  dc.Players.SOUTH ],
                                             [dc.Players.WEST,  dc.Players.SOUTH, dc.Players.EAST,  dc.Players.NORTH ],
                                             [dc.Players.NORTH, dc.Players.WEST,  dc.Players.SOUTH, dc.Players.EAST  ],
                                             [dc.Players.SOUTH, dc.Players.EAST,  dc.Players.NORTH, dc.Players.WEST  ], 
                                             [dc.Players.EAST,  dc.Players.NORTH, dc.Players.WEST,  dc.Players.SOUTH ],
                                             [dc.Players.SOUTH, dc.Players.EAST,  dc.Players.NORTH, dc.Players.WEST  ],
                                             [dc.Players.EAST,  dc.Players.NORTH, dc.Players.WEST,  dc.Players.SOUTH ] ])
        expected_last_round_cards = np.concatenate((expected_last_round_who[:, :, np.newaxis], expected_last_round_oindex[:, :, np.newaxis]), axis=2)
        c = (expected_last_round_cards == last_round_cards)

        last_winners = np.array([dc.Players.NORTH,  dc.Players.WEST,   #banker win
                                 dc.Players.WEST,   dc.Players.EAST,
                                 dc.Players.WEST,   dc.Players.NORTH,
                                 dc.Players.SOUTH,  dc.Players.EAST, 
                                 dc.Players.SOUTH,  dc.Players.EAST])

        return c.all()
    
    def test_collect_card_last_round_massive(self, last_winners, limit=100000):
        ######################################
        # base DATA variant: 
        #   self.full_poker.np_cards[:, :, dc.COL_PLAYED],   write
        #   self.full_poker.np_cards[:, :, dc.COL_OINDEX]
        #   self.full_poker.np_cards[:, :, dc.COL_WHO]
        #   self.full_poker.np_cards[:, :, dc.COL_DISCARDED]
        # NOTE: cardset should self.n
        self.shuffle_and_deal_cards() #clear DATA
        results = []
        for i in range(limit):
            last_round_played_oindex = self.test_collect_card_last_round_common_1_DATA(config=2)
            
            ######################################
            # base INPUT variant: 
            #   NOTE: cardsets != self.n
            last_winners = np.random.choice(self.players[0:4], size=self.n, replace=True)
            
            last_round_cards = self.collect_card_last_round(last_winners)

            expected_last_round_cards = self.collect_card_last_round0(last_winners)
            c = (np.array(expected_last_round_cards, dtype=np.int32) == last_round_cards)
            results.append(c.all())
            if i%1000 == 0:
                print('.', end='')
            if i%10000 == 0:
                print(i, end='')
                
        return np.array(results).all()
    
    def TEST_collect_card_last_round(self):
        ######################################
        # base DATA preparation: 
        #   self.full_poker.np_cards[:, :, dc.COL_PLAYED],   write
        #   self.full_poker.np_cards[:, :, dc.COL_OINDEX]
        #   self.full_poker.np_cards[:, :, dc.COL_WHO]
        #   self.full_poker.np_cards[:, :, dc.COL_DISCARDED]
        # NOTE: cardset should self.n
        self.shuffle_and_deal_cards() #need not sorting
        last_round_played_oindex = self.test_collect_card_last_round_common_1_DATA(config=1)
        '''
        s_full_played = self.full_poker.np_cards[:, :, dc.COL_PLAYED]
        s_full_discarded = self.full_poker.np_cards[:, :, dc.COL_DISCARDED]
        #s_full_who = self.full_poker.np_cards[:, :, dc.COL_WHO]
        s_full_oindex = self.full_poker.np_cards[:, :, dc.COL_OINDEX]
                                         #S     E     N     W
        senw_cards_template = np.array([ [0 ,   2 ,   6 ,   1 ],   #oindex, every player has 1 card
                                         [3 ,   7 ,   10,   5 ],
                                         [4 ,   11,   12,   9 ],
                                         [8 ,   27,   13,   15],
                                         [14,   28,   19,   20],
                                         [18,   33,   25,   29],
                                         [21,   42,   30,   31],
                                         [22,   44,   37,   32],
                                         [23,   46,   39,   34],
                                         [24,   49,   41,   36],
                                         [26,   51,   50,   40],
                                         [38,   52,   53,   48] ])
            
        last_round_played_oindex = senw_cards_template[:self.n]
        avail_cards_index = np.logical_not(s_full_discarded) #not play yet, it is right
        s_full_played[avail_cards_index] = True  #default as played, later will remove 4 cards
        for i, (oindex, played_oindex) in enumerate(zip(s_full_oindex, last_round_played_oindex)):
            oindex_4 = oindex[np.newaxis, :].repeat(4, axis=0)
            avail_pos = np.where(oindex_4 == played_oindex[:,np.newaxis])  #search 4 'played'
            s_full_played[i, avail_pos[1]] = False
        '''
        
        ######################################
        # base INPUT preparation: 
        #   NOTE: cardsets != self.n
        last_winners = np.array([dc.Players.NORTH,  dc.Players.WEST,   #banker win
                                 dc.Players.WEST,   dc.Players.EAST,
                                 dc.Players.WEST,   dc.Players.NORTH,
                                 dc.Players.SOUTH,  dc.Players.EAST, 
                                 dc.Players.SOUTH,  dc.Players.EAST])
        results = []
        # run sub testcase:
        results.append(self.test_collect_card_last_round_0(last_winners)) #, last_round_played_oindex))
        if self.test_auto_level > 0 :
            results.append(self.test_collect_card_last_round_massive(last_winners))
            print("\n")
                
        result = np.array(results).all()
        print("PokerEnvironment_6_1::collect_card_last_round() ", result, results)
        
    def test_step_play_1card_common1_senw(self, player_x, fmt_x, oindexes_x, slice_cross_players, tuple_crossing_see, rounds, in_round_oindex=[]): #rounds=0-11, 第几轮
        #playing seq = S(winner), E, N, W(last), MUST。 player is same crossing cardsets
        
        state3s_0 = copy.deepcopy(self.state3s)
        players_x = np.array([player_x]*self.n)
        np_player_oindex = np.concatenate((players_x[:,np.newaxis], oindexes_x[:,np.newaxis]), axis=1)[:,np.newaxis,:]
        if not in_round_oindex:
            np_in_round_oindex = np_player_oindex
        else:
            np_in_round_oindex = np.concatenate((np.array(in_round_oindex).astype(np.int16), np_player_oindex), axis=1)
        in_round_oindex = list(np_in_round_oindex)
        state3s, _ = self.step_play_1card(players_x, fmt_x, oindexes_x, in_round_oindex=in_round_oindex)
        #slice_cross_players = np.s_[1,2,3]
        
        cardset_all_players_inhand = state3s[:,:,0,:]
        cardset_all_players_played = state3s[:,:,1,:]
        cardset_0_players_seen = state3s[0,slice_cross_players,2:5,:]
        cardset_n_players_seen = state3s[self.n-1,slice_cross_players,2:5,:]
        cardset_0_players_seen_pre = state3s_0[0,slice_cross_players,2:5,:]
        cardset_n_players_seen_pre = state3s_0[self.n-1,slice_cross_players,2:5,:]
        
        #inhand
        c1 = (cardset_all_players_inhand[np.arange(self.n), player_x-1, oindexes_x] == 0)
        if dc.Players.WEST == player_x:
            #last player. need not forward counting
            c2 = np.array([True])
            c3 = c2
        else:
            #player_x ~ 4, check: all 12 card in hand
            not_played0 = (cardset_all_players_inhand[:,player_x:4] > 0)
            not_played1 = np.sum(not_played0, axis=2)
            c2 = (not_played1 == (12-rounds))
            if 0 == rounds:
                expected_oindex = np.array([1,5,9,15,20,29,31,32,34,36,40,48]) #WEST card = last player
                c3 = (cardset_all_players_inhand[:,3, expected_oindex] > 0)
            else:
                #the rounds other than 0, the expected_oindex of WEST is variant. ignore
                c3 = np.array([True])
        
        #played
        c4 = (cardset_all_players_played[np.arange(self.n), player_x-1, oindexes_x] == fmt_x)
        if dc.Players.WEST == player_x:
            c5 = np.array([True])
        else:
            #player_x ~ 4, check: the 10 played cards should not be in 'played' of state3
            c5 = (cardset_all_players_played[:, player_x:4, oindexes_x] == 0)
        
        #crossing seen
        cardset_0_players_seen_diff = np.where((cardset_0_players_seen == cardset_0_players_seen_pre) == False)
        cardset_n_players_seen_diff = np.where((cardset_n_players_seen == cardset_n_players_seen_pre) == False)
        c6 = (cardset_0_players_seen_diff[2] == oindexes_x[0])
        c7 = (cardset_n_players_seen_diff[2] == oindexes_x[self.n-1])
        player_crossing_seen_0 = np.concatenate((cardset_0_players_seen_diff[0][np.newaxis,:], cardset_0_players_seen_diff[1][np.newaxis,:]), axis=0).T
        player_crossing_seen_n = np.concatenate((cardset_n_players_seen_diff[0][np.newaxis,:], cardset_n_players_seen_diff[1][np.newaxis,:]), axis=0).T
        
        c8 = ( player_crossing_seen_0 == tuple_crossing_see )
        c9 = ( player_crossing_seen_n == tuple_crossing_see )
        c10 = (cardset_0_players_seen[cardset_0_players_seen_diff[0], cardset_0_players_seen_diff[1], cardset_0_players_seen_diff[2]] == fmt_x[0])
        c11 = (cardset_n_players_seen[cardset_n_players_seen_diff[0], cardset_n_players_seen_diff[1], cardset_n_players_seen_diff[2]] == fmt_x[self.n-1])
        
        if player_x == self.full_poker.np_bankers[0] :
            played_pos = np.where(self.players_cards[0][:,:,dc.COL_OINDEX] == oindexes_x[:,np.newaxis])
            c12 = (self.players_cards[0][np.arange(self.n), played_pos[1], dc.COL_PLAYED] == True)
        else:
            #'player_x-1-1' works since SOUTH is the only banker
            played_pos = np.where(self.players_cards[1][:, player_x-1-1, :, dc.COL_OINDEX] == oindexes_x[:,np.newaxis])
            c12 = (self.players_cards[1][np.arange(self.n), player_x-1-1, played_pos[1], dc.COL_PLAYED] == True)

        c = ( c1.all() and c2.all() and c3.all() and c4.all() and c5.all() and \
              c6.all() and c7.all() and c8.all() and c9.all() and c10.all() and \
              c11.all() and c12.all() )
        if False == c:
            print("test_step_play_1card_0 failed")
            return False, ErrorIDs.ERR_MISC
        
        return True, in_round_oindex

    def test_step_play_1card_common2_anysenw(self, players_x, fmt_x, oindexes_x, in_round_oindex=[]): #rounds=0-11, 第几轮
        #random winner
        
        state3s_0 = copy.deepcopy(self.state3s)
        #players_x = np.array([player_x]*self.n)
        np_player_oindex = np.concatenate((players_x[:,np.newaxis], oindexes_x[:,np.newaxis]), axis=1)[:,np.newaxis,:].astype(np.int16)
        if not in_round_oindex:
            np_in_round_oindex = np_player_oindex
        else:
            np_in_round_oindex = np.concatenate((np.array(in_round_oindex).astype(np.int16), np_player_oindex), axis=1)
        in_round_oindex = list(np_in_round_oindex)
        state3s, _ = self.step_play_1card(players_x, fmt_x, oindexes_x, in_round_oindex=in_round_oindex)
        
        state3s_diff_pos = np.where(state3s != state3s_0)
        #shape(n,4,5,54)
        np_state3s_diff_pos = np.concatenate((state3s_diff_pos[0][:,np.newaxis], state3s_diff_pos[1][:,np.newaxis], state3s_diff_pos[2][:,np.newaxis], state3s_diff_pos[3][:,np.newaxis]), axis=1)

        #dim4_template = np.array([0, 1, 2, 3])
        dim5_template = np.array([1, 4, 3, 2]) #exclude 'inhand'. S=0=not rolling. refer to 'state3s_diff_pos' shapshot template in xx_3()
        
        #inhand
        inhand_pos_index = np.where(np_state3s_diff_pos[:,2]==0)
        inhand_pos = np_state3s_diff_pos[inhand_pos_index[0]]  #value in col=2 is 0
        dim4_offset = players_x-1
        c1 = (inhand_pos[:,0] == np.arange(self.n))
        c2 = (inhand_pos[:,1] == dim4_offset)
        c3 = (inhand_pos[:,3] == oindexes_x)
        c4 = (state3s[inhand_pos[:,0], inhand_pos[:,1], 0, inhand_pos[:,3]] == 0)

        #played and others
        played_pos_index = np.where(np_state3s_diff_pos[:,2] != 0)
        played_pos = np_state3s_diff_pos[played_pos_index]
        dim5_offsets = np.array([])
        for player in players_x:
            dim5_offset = np.roll(dim5_template, shift=player-1)
            if 0 == dim5_offsets.shape[0]:
                dim5_offsets = dim5_offset
            else:
                dim5_offsets = np.concatenate((dim5_offsets, dim5_offset))

        c5 = (played_pos[:,0] == np.arange(self.n).repeat(4))
        c6 = (played_pos[:,1] == np.arange(4)[np.newaxis,:].repeat(self.n, axis=0).reshape(-1))
        c7 = (played_pos[:,2] == dim5_offsets)
        c8 = (played_pos[:,3] == oindexes_x.repeat(4))
        c9 = (state3s[played_pos[:,0], played_pos[:,1], played_pos[:,2], played_pos[:,3]] == fmt_x.repeat(4))

        #self.players_cards[0]/[1]: loop in low efficency, which alg is diff to target method
        c10s = []
        for i, player in enumerate(players_x): #size = n
            if player == self.full_poker.np_bankers[i] :
                played_pos = np.where(self.players_cards[0][i,:,dc.COL_OINDEX] == oindexes_x[i])
                c10 = (self.players_cards[0][i, played_pos[0], dc.COL_PLAYED] == True)
            else:
                #'player_x-1-1' works since SOUTH is the only banker
                played_pos = np.where(self.players_cards[1][i, player-1-1, :, dc.COL_OINDEX] == oindexes_x[i])
                c10 = (self.players_cards[1][i, player-1-1, played_pos[0], dc.COL_PLAYED] == True)
            c10s.append(c10)
        c10 = np.array(c10s)
        
        c = ( c1.all() and c2.all() and c3.all() and c4.all() and c5.all() and \
              c6.all() and c7.all() and c8.all() and c9.all() and c10.all() )
        if False == c:
            print("test_step_play_1card_2 failed")
            return False, ErrorIDs.ERR_MISC

        return True, in_round_oindex

    def test_step_play_1card_0(self):
        #play the first round: S-E-N-W
        results = []
        fmt2, fmt3 = self.net_input_format[2], self.net_input_format[3]
        
        player_x = dc.Players.SOUTH
        oindexes_x = np.array([0, 3, 8, 14, 18, 22, 23, 24, 26, 38])
        fmt_x = np.array([fmt3, fmt3, fmt3, fmt3, fmt2, fmt2, fmt2, fmt2, fmt2, fmt2])
        in_round_oindex=[]
        slice_cross_players = np.s_[1,2,3]
        tuple_crossing_seen = np.array([[0,2], [1,1], [2,0]])
        rounds = 0
        result, in_round_oindex = self.test_step_play_1card_common1_senw(player_x, fmt_x, oindexes_x, slice_cross_players, tuple_crossing_seen, rounds, in_round_oindex=in_round_oindex)
        results.append(result)

        player_x = dc.Players.EAST
        oindexes_x = np.array([7, 11, 27, 28, 33, 42, 44, 49, 51, 52])
        fmt_x = np.array([fmt3, fmt3, fmt3, fmt2, fmt2, fmt2, fmt2, fmt2, fmt2, fmt3])
        slice_cross_players = np.s_[0,2,3]
        tuple_crossing_seen = np.array([[0,0], [1,2], [2,1]])
        rounds = 0
        result, in_round_oindex = self.test_step_play_1card_common1_senw(player_x, fmt_x, oindexes_x, slice_cross_players, tuple_crossing_seen, rounds, in_round_oindex=in_round_oindex)
        results.append(result)
        
        player_x = dc.Players.NORTH
        oindexes_x = np.array([12, 13, 19, 25, 30, 37, 39, 41, 50, 53])
        fmt_x = np.array([fmt3, fmt2, fmt2, fmt2, fmt2, fmt2, fmt2, fmt2, fmt2, fmt3])
        slice_cross_players = np.s_[0,1,3]
        tuple_crossing_seen = np.array([[0,1], [1,0], [2,2]])
        rounds = 0
        result, in_round_oindex = self.test_step_play_1card_common1_senw(player_x, fmt_x, oindexes_x, slice_cross_players, tuple_crossing_seen, rounds, in_round_oindex=in_round_oindex)
        results.append(result)

        player_x = dc.Players.WEST
        oindexes_x = np.array([1, 5, 15, 20, 29, 31, 32, 34, 36, 40])
        fmt_x = np.array([fmt3, fmt3, fmt2, fmt2, fmt2, fmt2, fmt2, fmt2, fmt2, fmt3])
        slice_cross_players = np.s_[0,1,2]
        tuple_crossing_seen = np.array([[0,2], [1,1], [2,0]])
        rounds = 0
        result, in_round_oindex = self.test_step_play_1card_common1_senw(player_x, fmt_x, oindexes_x, slice_cross_players, tuple_crossing_seen, rounds, in_round_oindex=in_round_oindex)
        results.append(result)
        
        return np.array(results).all()
    
    #following xx_0()
    def test_step_play_1card_1(self):
        #play the second-thenth round: S-E-N-W. not init the DATA
        results = []
        fmt2, fmt3 = self.net_input_format[2], self.net_input_format[3]
        
        for rounds in range(1,9): #only 10 cards(xx_0() plus xx_1()) selecetd and played
            oindexes_x0 = np.array([0, 3, 8, 14, 18, 22, 23, 24, 26, 38])
            fmt_x0 = np.array([fmt3, fmt3, fmt3, fmt3, fmt2, fmt2, fmt2, fmt2, fmt2, fmt2])
            oindexes_x = np.roll(oindexes_x0, rounds)
            fmt_x = np.roll(fmt_x0, rounds)
            player_x = dc.Players.SOUTH
            in_round_oindex=[]
            slice_cross_players = np.s_[1,2,3]
            tuple_crossing_seen = np.array([[0,2], [1,1], [2,0]])
            result, in_round_oindex = self.test_step_play_1card_common1_senw(player_x, fmt_x, oindexes_x, slice_cross_players, tuple_crossing_seen, rounds, in_round_oindex=in_round_oindex)
            results.append(result)
    
            oindexes_x0 = np.array([7, 11, 27, 28, 33, 42, 44, 49, 51, 52])
            fmt_x0 = np.array([fmt3, fmt3, fmt3, fmt2, fmt2, fmt2, fmt2, fmt2, fmt2, fmt3])
            oindexes_x = np.roll(oindexes_x0, rounds)
            fmt_x = np.roll(fmt_x0, rounds)
            player_x = dc.Players.EAST
            slice_cross_players = np.s_[0,2,3]
            tuple_crossing_seen = np.array([[0,0], [1,2], [2,1]])
            result, in_round_oindex = self.test_step_play_1card_common1_senw(player_x, fmt_x, oindexes_x, slice_cross_players, tuple_crossing_seen, rounds, in_round_oindex=in_round_oindex)
            results.append(result)
            
            oindexes_x0 = np.array([12, 13, 19, 25, 30, 37, 39, 41, 50, 53])
            fmt_x0 = np.array([fmt3, fmt2, fmt2, fmt2, fmt2, fmt2, fmt2, fmt2, fmt2, fmt3])
            oindexes_x = np.roll(oindexes_x0, rounds)
            fmt_x = np.roll(fmt_x0, rounds)
            player_x = dc.Players.NORTH
            slice_cross_players = np.s_[0,1,3]
            tuple_crossing_seen = np.array([[0,1], [1,0], [2,2]])
            result, in_round_oindex = self.test_step_play_1card_common1_senw(player_x, fmt_x, oindexes_x, slice_cross_players, tuple_crossing_seen, rounds, in_round_oindex=in_round_oindex)
            results.append(result)
    
            oindexes_x0 = np.array([1, 5, 15, 20, 29, 31, 32, 34, 36, 40])
            fmt_x0 = np.array([fmt3, fmt3, fmt2, fmt2, fmt2, fmt2, fmt2, fmt2, fmt2, fmt3])
            oindexes_x = np.roll(oindexes_x0, rounds)
            fmt_x = np.roll(fmt_x0, rounds)
            player_x = dc.Players.WEST
            slice_cross_players = np.s_[0,1,2]
            tuple_crossing_seen = np.array([[0,2], [1,1], [2,0]])
            result, in_round_oindex = self.test_step_play_1card_common1_senw(player_x, fmt_x, oindexes_x, slice_cross_players, tuple_crossing_seen, rounds, in_round_oindex=in_round_oindex)
            results.append(result)
        
        return np.array(results).all()

    def test_step_play_1card_common3_build_inputs(self, fmt2, fmt3, card_pattern=cards_7307): #unique pattern
        senw_oindex = np.zeros((4,12), dtype=np.int16)  #imdex by playername-1(S-E-N-W)
        senw_oindex[0] = card_pattern[np.logical_and(card_pattern[:,dc.COL_WHO] == dc.Players.SOUTH, card_pattern[:,dc.COL_DISCARDED] == False), dc.COL_OINDEX]
        senw_oindex[1] = card_pattern[card_pattern[:,dc.COL_WHO] == dc.Players.EAST, dc.COL_OINDEX]
        senw_oindex[2] = card_pattern[card_pattern[:,dc.COL_WHO] == dc.Players.NORTH, dc.COL_OINDEX]
        senw_oindex[3] = card_pattern[card_pattern[:,dc.COL_WHO] == dc.Players.WEST, dc.COL_OINDEX]
        senw_trump = np.zeros((4,12))  #imdex by playername-1(S-E-N-W)
        senw_trump[0] = np.where(card_pattern[np.logical_and(card_pattern[:,dc.COL_WHO] == dc.Players.SOUTH, card_pattern[:,dc.COL_DISCARDED] == False), dc.COL_TRUMP]==True, fmt3, fmt2)
        senw_trump[1] = np.where(card_pattern[card_pattern[:,dc.COL_WHO] == dc.Players.EAST, dc.COL_TRUMP]==True, fmt3, fmt2)
        senw_trump[2] = np.where(card_pattern[card_pattern[:,dc.COL_WHO] == dc.Players.NORTH, dc.COL_TRUMP]==True, fmt3, fmt2)
        senw_trump[3] = np.where(card_pattern[card_pattern[:,dc.COL_WHO] == dc.Players.WEST, dc.COL_TRUMP]==True, fmt3, fmt2)

        repeats = np.ceil(self.n/4)
        first_players = self.players[0:4][np.newaxis,:].repeat(repeats, axis=0).reshape(-1)[:self.n]  #fixed winner
        
        #shape(n,4,12), 4 players with 12 rounds. a slice in 'round' is a input oindexes to env.step_play_1card()
        round_players_oindexes = np.zeros((self.n, 4, 12), dtype=np.int16)  #dim(4)不是player， 而是player_seq. [0]=first_players [1]=first_players+1, ...
        round_players_trumps = np.zeros((self.n, 4, 12))
        
        for cardset in range(self.n):
            for player_seq in range(4): #4 players. loop容易理解，在UT,不考虑efficency
                #根据first_players算出每一round的player sequence,
                player = self.players[first_players[cardset] - 1 + player_seq] - 1
                #按cardset位移，保证没有相同的card组合
                round_players_oindexes[cardset, player_seq] = np.roll(senw_oindex[player], shift=cardset, axis=0)
                round_players_trumps[cardset, player_seq] = np.roll(senw_trump[player], shift=cardset, axis=0)
        
        return round_players_oindexes, round_players_trumps, first_players

    def test_step_play_1card_common3_build_inputs2(self, fmt2, fmt3): #random np_cards, no pattern
        first_players = np.random.choice(self.players[0:4], size=10, replace=True) #here the first player would be diff to SOUTH=banker. SOUTH=banker since discard and env.players_cards[0]/[1]
        np_cards = self.full_poker.np_cards
        
        #shape(n,4,12), 4 players with 12 rounds. a slice in 'round' is a input oindexes to env.step_play_1card()
        round_players_oindexes = np.zeros((self.n, 4, 12), dtype=np.int16)  #dim(4)不是player， 而是player_seq. [0]=first_players [1]=first_players+1, ...
        round_players_trumps = np.zeros((self.n, 4, 12))
        
        for cardset in range(self.n):
            np_card = np_cards[cardset]
            for player_seq in range(4): #4 players,index of dim(2) of round_players_oindexes. it is NOT S-E-N-W. loop容易理解，在UT,不考虑efficency
                #根据first_players算出每一round的player sequence,
                player = self.players[first_players[cardset] - 1 + player_seq] - 1

                senw_oindex = np.zeros((4,12), dtype=np.int16)  #imdex by playername-1(S-E-N-W)
                senw_oindex[0] = np_card[np.logical_and(np_card[:,dc.COL_WHO] == dc.Players.SOUTH, np_card[:,dc.COL_DISCARDED] == False), dc.COL_OINDEX]
                senw_oindex[1] = np_card[np_card[:,dc.COL_WHO] == dc.Players.EAST, dc.COL_OINDEX]
                senw_oindex[2] = np_card[np_card[:,dc.COL_WHO] == dc.Players.NORTH, dc.COL_OINDEX]
                senw_oindex[3] = np_card[np_card[:,dc.COL_WHO] == dc.Players.WEST, dc.COL_OINDEX]
                senw_trump = np.zeros((4,12))  #imdex by playername-1(S-E-N-W)
                senw_trump[0] = np.where(np_card[np.logical_and(np_card[:,dc.COL_WHO] == dc.Players.SOUTH, np_card[:,dc.COL_DISCARDED] == False), dc.COL_TRUMP]==True, fmt3, fmt2)
                senw_trump[1] = np.where(np_card[np_card[:,dc.COL_WHO] == dc.Players.EAST, dc.COL_TRUMP]==True, fmt3, fmt2)
                senw_trump[2] = np.where(np_card[np_card[:,dc.COL_WHO] == dc.Players.NORTH, dc.COL_TRUMP]==True, fmt3, fmt2)
                senw_trump[3] = np.where(np_card[np_card[:,dc.COL_WHO] == dc.Players.WEST, dc.COL_TRUMP]==True, fmt3, fmt2)

                shuffle_template = np.random.random((12))
                index_12 = np.argsort(shuffle_template)
                round_players_oindexes[cardset, player_seq] = senw_oindex[player][index_12]
                round_players_trumps[cardset, player_seq] = senw_trump[player][index_12]
        
        return round_players_oindexes, round_players_trumps, first_players
    
    def test_step_play_1card_common4_error(self):
        print("step_play_1card error. TBD")

    
    def test_step_play_1card_2(self):
        #(1)play all 12 rounds, (2)verify via comparing the state3s (3) variant winner
        ######################################
        # base DATA preparation: same as TEST_xxx main entry
        # in env:
        #   self.n: 与game_envs.n一致
        #   self.players_cards[0]/[1]..[played]. overwrite
        #   self.render = False
        #   self.state3s[], it is output
        # in env.full_poker:
        #   self.full_poker.np_cards[played]. overwrite [self.n, ..]
        #   self.full_poker.np_cards[who]. overwrite [self.n, ..]
        #   self.full_poker.np_cards[discard]. overwrite [self.n, ..]
        #   self.full_poker.np_bankers
        #   self.full_poker.np_trumps
        #   self.full_poker.np_rounds
        #self.render = True
        fmt2, fmt3 = self.net_input_format[2], self.net_input_format[3]
        self.assign_full_poker_np_trumps()
        self.assign_full_poker_np_bankers()  #only support 'all bankers are same' @shuffle_cards()
        self.assign_full_poker_np_rounds()
        self.shuffle_and_deal_cards() #need not sorting
        self.discard_cards()
        self.players_cards = self.init_all_player_cards()
        self.np_start_player_cards = self.players_cards[0]
        self.state3_reset(fmt2, fmt3)

        ######################################
        # base INPUT:
        #   players_x
        #   fmt_x
        #   oindexes_x, 
        #   in_round_oindex=[],
        # assume len=10
        round_players_oindexes, round_players_trumps, first_players = self.test_step_play_1card_common3_build_inputs(fmt2, fmt3)
        '''
        senw_oindex = np.zeros((4,12), dtype=np.int16)  #imdex by playername-1(S-E-N-W)
        senw_oindex[0] = cards_7307[np.logical_and(cards_7307[:,dc.COL_WHO] == dc.Players.SOUTH, cards_7307[:,dc.COL_DISCARDED] == False), dc.COL_OINDEX]
        senw_oindex[1] = cards_7307[cards_7307[:,dc.COL_WHO] == dc.Players.EAST, dc.COL_OINDEX]
        senw_oindex[2] = cards_7307[cards_7307[:,dc.COL_WHO] == dc.Players.NORTH, dc.COL_OINDEX]
        senw_oindex[3] = cards_7307[cards_7307[:,dc.COL_WHO] == dc.Players.WEST, dc.COL_OINDEX]
        senw_trump = np.zeros((4,12))  #imdex by playername-1(S-E-N-W)
        senw_trump[0] = np.where(cards_7307[np.logical_and(cards_7307[:,dc.COL_WHO] == dc.Players.SOUTH, cards_7307[:,dc.COL_DISCARDED] == False), dc.COL_TRUMP]==True, fmt3, fmt2)
        senw_trump[1] = np.where(cards_7307[cards_7307[:,dc.COL_WHO] == dc.Players.EAST, dc.COL_TRUMP]==True, fmt3, fmt2)
        senw_trump[2] = np.where(cards_7307[cards_7307[:,dc.COL_WHO] == dc.Players.NORTH, dc.COL_TRUMP]==True, fmt3, fmt2)
        senw_trump[3] = np.where(cards_7307[cards_7307[:,dc.COL_WHO] == dc.Players.WEST, dc.COL_TRUMP]==True, fmt3, fmt2)

        repeats = np.ceil(self.n/4)
        first_players = self.players[0:4][np.newaxis,:].repeat(repeats, axis=0).reshape(-1)[:self.n]  #fixed winner. np.random.choice(self.players[0:4], size=(10,), replace=True)
        
        #shape(n,4,12), 4 players with 12 rounds. a slice in 'round' is a input oindexes to env.step_play_1card()
        round_players_oindexes = np.zeros((self.n, 4, 12), dtype=np.int16)  #dim(4)不是player， 而是player_seq. [0]=first_players [1]=first_players+1, ...
        round_players_trumps = np.zeros((self.n, 4, 12))
        
        for cardset in range(self.n):
            for player_seq in range(4): #4 players. loop容易理解，在UT,不考虑efficency
                #根据first_players算出每一round的player sequence,
                player = self.players[first_players[cardset] - 1 + player_seq] - 1
                #按cardset位移，保证没有相同的card组合
                round_players_oindexes[cardset, player_seq] = np.roll(senw_oindex[player], shift=cardset, axis=0)
                round_players_trumps[cardset, player_seq] = np.roll(senw_trump[player], shift=cardset, axis=0)
        '''
        
        results = []
        for rounds in range(12):
            #for a specific cardset, the start player keep same
            in_round_oindex = []
            #print("round: ", rounds)
            for player_seq in range(4): #4 players
                oindexes_x = round_players_oindexes[:, player_seq, rounds]
                fmt_x = round_players_trumps[:, player_seq, rounds]
                result, in_round_oindex = self.test_step_play_1card_common2_anysenw(self.players[first_players - 1 + player_seq], 
                                                                                    fmt_x, oindexes_x, in_round_oindex=in_round_oindex)
                results.append(result)

        return np.array(results).all()

    def test_step_play_1card_3(self):
         #case is same to xx_2(), diff: shapshot comparison. works only in config=800(10 cardsets). 
        ######################################
        # base DATA preparation: same as TEST_xxx main entry
        # in env:
        #   self.n: 与game_envs.n一致
        #   self.players_cards[0]/[1]..[played]. overwrite
        #   self.render = False
        #   self.state3s[], it is output
        # in env.full_poker:
        #   self.full_poker.np_cards[played]. overwrite [self.n, ..]
        #   self.full_poker.np_cards[who]. overwrite [self.n, ..]
        #   self.full_poker.np_cards[discard]. overwrite [self.n, ..]
        #   self.full_poker.np_bankers
        #   self.full_poker.np_trumps
        #   self.full_poker.np_rounds
        #self.render = True
        fmt2, fmt3 = self.net_input_format[2], self.net_input_format[3]
        self.assign_full_poker_np_trumps()
        self.assign_full_poker_np_bankers()  #only support 'all bankers are same' @shuffle_cards()
        self.assign_full_poker_np_rounds()
        self.shuffle_and_deal_cards() #need not sorting
        self.discard_cards()
        self.players_cards = self.init_all_player_cards()
        self.np_start_player_cards = self.players_cards[0]
        self.state3_reset(fmt2, fmt3)

        ######################################
        # base INPUT:
        #   players_x
        #   fmt_x
        #   oindexes_x, 
        #   in_round_oindex=[],
        # assume len=10
        round_players_oindexes, round_players_trumps, first_players = self.test_step_play_1card_common3_build_inputs(fmt2, fmt3)
        state3s_diff_r2 = np.array([[0,	0,	3,	6 ],
                                    [0,	1,	2,	6 ],
                                    [0,	2,	0,	6 ],
                                    [0,	2,	1,	6 ],
                                    [0,	3,	4,	6 ],
                                    [1,	0,	4,	48],
                                    [1,	1,	3,	48],
                                    [1,	2,	2,	48],
                                    [1,	3,	0,	48],
                                    [1,	3,	1,	48],
                                    [2,	0,	0,	26],
                                    [2,	0,	1,	26],
                                    [2,	1,	4,	26],
                                    [2,	2,	3,	26],
                                    [2,	3,	2,	26],
                                    [3,	0,	2,	49],
                                    [3,	1,	0,	49],
                                    [3,	1,	1,	49],
                                    [3,	2,	4,	49],
                                    [3,	3,	3,	49],
                                    [4,	0,	3,	39],
                                    [4,	1,	2,	39],
                                    [4,	2,	0,	39],
                                    [4,	2,	1,	39],
                                    [4,	3,	4,	39],
                                    [5,	0,	4,	32],
                                    [5,	1,	3,	32],
                                    [5,	2,	2,	32],
                                    [5,	3,	0,	32],
                                    [5,	3,	1,	32],
                                    [6,	0,	0,	21],
                                    [6,	0,	1,	21],
                                    [6,	1,	4,	21],
                                    [6,	2,	3,	21],
                                    [6,	3,	2,	21],
                                    [7,	0,	2,	33],
                                    [7,	1,	0,	33],
                                    [7,	1,	1,	33],
                                    [7,	2,	4,	33],
                                    [7,	3,	3,	33],
                                    [8,	0,	3,	19],
                                    [8,	1,	2,	19],
                                    [8,	2,	0,	19],
                                    [8,	2,	1,	19],
                                    [8,	3,	4,	19],
                                    [9,	0,	4,	15],
                                    [9,	1,	3,	15],
                                    [9,	2,	2,	15],
                                    [9,	3,	0,	15],
                                    [9,	3,	1,	15] ])

        state3s_diff_r30 = np.array([[0,	0,	3,	37],
                                    [0,	1,	2,	37],
                                    [0,	2,	0,	37],
                                    [0,	2,	1,	37],
                                    [0,	3,	4,	37],
                                    [1,	0,	4,	31],
                                    [1,	1,	3,	31],
                                    [1,	2,	2,	31],
                                    [1,	3,	0,	31],
                                    [1,	3,	1,	31],
                                    [2,	0,	0,	18],
                                    [2,	0,	1,	18],
                                    [2,	1,	4,	18],
                                    [2,	2,	3,	18],
                                    [2,	3,	2,	18],
                                    [3,	0,	2,	28],
                                    [3,	1,	0,	28],
                                    [3,	1,	1,	28],
                                    [3,	2,	4,	28],
                                    [3,	3,	3,	28],
                                    [4,	0,	3,	13],
                                    [4,	1,	2,	13],
                                    [4,	2,	0,	13],
                                    [4,	2,	1,	13],
                                    [4,	3,	4,	13],
                                    [5,	0,	4,	9 ],
                                    [5,	1,	3,	9 ],
                                    [5,	2,	2,	9 ],
                                    [5,	3,	0,	9 ],
                                    [5,	3,	1,	9 ],
                                    [6,	0,	0,	3],
                                    [6,	0,	1,	3],
                                    [6,	1,	4,	3],
                                    [6,	2,	3,	3],
                                    [6,	3,	2,	3],
                                    [7,	0,	2,	2],
                                    [7,	1,	0,	2],
                                    [7,	1,	1,	2],
                                    [7,	2,	4,	2],
                                    [7,	3,	3,	2],
                                    [8,	0,	3,	53],
                                    [8,	1,	2,	53],
                                    [8,	2,	0,	53],
                                    [8,	2,	1,	53],
                                    [8,	3,	4,	53],
                                    [9,	0,	4,	40],
                                    [9,	1,	3,	40],
                                    [9,	2,	2,	40],
                                    [9,	3,	0,	40],
                                    [9,	3,	1,	40] ])

        state3s_diff_r46 = np.array([[0,	0,	3,	53],
                                    [0,	1,	2,	53],
                                    [0,	2,	0,	53],
                                    [0,	2,	1,	53],
                                    [0,	3,	4,	53],
                                    [1,	0,	4,	40],
                                    [1,	1,	3,	40],
                                    [1,	2,	2,	40],
                                    [1,	3,	0,	40],
                                    [1,	3,	1,	40],
                                    [2,	0,	0,	24],
                                    [2,	0,	1,	24],
                                    [2,	1,	4,	24],
                                    [2,	2,	3,	24],
                                    [2,	3,	2,	24],
                                    [3,	0,	2,	46],
                                    [3,	1,	0,	46],
                                    [3,	1,	1,	46],
                                    [3,	2,	4,	46],
                                    [3,	3,	3,	46],
                                    [4,	0,	3,	37],
                                    [4,	1,	2,	37],
                                    [4,	2,	0,	37],
                                    [4,	2,	1,	37],
                                    [4,	3,	4,	37],
                                    [5,	0,	4,	31],
                                    [5,	1,	3,	31],
                                    [5,	2,	2,	31],
                                    [5,	3,	0,	31],
                                    [5,	3,	1,	31],
                                    [6,	0,	0,	18],
                                    [6,	0,	1,	18],
                                    [6,	1,	4,	18],
                                    [6,	2,	3,	18],
                                    [6,	3,	2,	18],
                                    [7,	0,	2,	28],
                                    [7,	1,	0,	28],
                                    [7,	1,	1,	28],
                                    [7,	2,	4,	28],
                                    [7,	3,	3,	28],
                                    [8,	0,	3,	13],
                                    [8,	1,	2,	13],
                                    [8,	2,	0,	13],
                                    [8,	2,	1,	13],
                                    [8,	3,	4,	13],
                                    [9,	0,	4,	9 ],
                                    [9,	1,	3,	9 ],
                                    [9,	2,	2,	9 ],
                                    [9,	3,	0,	9 ],
                                    [9,	3,	1,	9 ] ])

        counter = 0
        expected_counters = [2,30,46]
        for rounds in range(12):
            #for a specific cardset, the start player keep same
            in_round_oindex = []
            #print("round: ", rounds)
            for player_seq in range(4): #4 players
                players_x = self.players[first_players - 1 + player_seq]
                oindexes_x = round_players_oindexes[:, player_seq, rounds]
                fmt_x = round_players_trumps[:, player_seq, rounds]
                
                np_player_oindex = np.concatenate((players_x[:,np.newaxis], oindexes_x[:,np.newaxis]), axis=1)[:,np.newaxis,:].astype(np.int16)
                if not in_round_oindex:
                    np_in_round_oindex = np_player_oindex
                else:
                    np_in_round_oindex = np.concatenate((np.array(in_round_oindex).astype(np.int16), np_player_oindex), axis=1)
                in_round_oindex = list(np_in_round_oindex)

                if counter in expected_counters:
                    state3s_0 = copy.deepcopy(self.state3s)
                state3s, _ = self.step_play_1card(players_x, fmt_x, oindexes_x, in_round_oindex=in_round_oindex)

                if counter in expected_counters:
                    state3s_diff_pos = np.where(state3s != state3s_0)
                    #shape(n,4,5,54)
                    np_state3s_diff_pos = np.concatenate((state3s_diff_pos[0][:,np.newaxis], state3s_diff_pos[1][:,np.newaxis], state3s_diff_pos[2][:,np.newaxis], state3s_diff_pos[3][:,np.newaxis]), axis=1)
                    if 2 == counter:
                        c1 = (state3s_diff_r2 == np_state3s_diff_pos)
                    elif 30 == counter:
                        c2 = (state3s_diff_r30 == np_state3s_diff_pos)
                    elif 46 == counter:
                        c3 = (state3s_diff_r46 == np_state3s_diff_pos)
                counter += 1
        
        c = c1.all() and c2.all() and c3.all()
        if False == c:
            print("test_step_play_1card_3 failed")
            return False
        return True

    #based off xx_2()
    def test_step_play_1card_massive(self, limit=10000):
        #(1)random card deal, (2)random first player (3)random rolling offset (4)random trump and round
        ######################################
        # base DATA preparation: same as TEST_xxx main entry
        # in env:
        #   self.n: 与game_envs.n一致
        #   self.players_cards[0]/[1]..[played]. overwrite
        #   self.render = False
        #   self.state3s[], it is output
        # in env.full_poker:
        #   self.full_poker.np_cards[played]. overwrite [self.n, ..]
        #   self.full_poker.np_cards[who]. overwrite [self.n, ..]
        #   self.full_poker.np_cards[discard]. overwrite [self.n, ..]
        #   self.full_poker.np_bankers
        #   self.full_poker.np_trumps
        #   self.full_poker.np_rounds
        # side tested method:
        #   self.full_poker.set_trumps_banker()  *****
        
        self.render = False
        fmt2, fmt3 = self.net_input_format[2], self.net_input_format[3]
        
        results = []
        for i in range(limit):
            trumps = np.random.choice([dc.CardSuits.SPADES, dc.CardSuits.HEARTS, dc.CardSuits.CLUBS, dc.CardSuits.DIAMONDS], size=self.n, replace=True)
            rounds = np.random.choice(np.arange(13), size=self.n, replace=True) #discard doesn't support round!=2. but playing with round!=2 is OK
            #bankers = np.random.choice(players[0:4], size=self.n, replace=True) ##only support 'all bankers=SOUTH
            bankers = np.array([dc.Players.SOUTH]*self.n)
            
            #self.assign_full_poker_np_trumps(trumps)
            #self.assign_full_poker_np_rounds(rounds)
            self.assign_full_poker_np_cards()
            self.full_poker.set_trumps_banker(trumps, rounds, bankers)
            self.shuffle_and_deal_cards2(seed=np.random.randint(limit))
            self.discard_cards2() #regadless the discarded cards
            self.players_cards = self.init_all_player_cards()
            self.np_start_player_cards = self.players_cards[0]
            self.state3_reset(fmt2, fmt3)
            
            ######################################
            # base INPUT:
            #   players_x
            #   fmt_x
            #   oindexes_x, 
            #   in_round_oindex=[],
            # assume len=10
            round_players_oindexes, round_players_trumps, first_players = self.test_step_play_1card_common3_build_inputs2(fmt2, fmt3)
            
            for rounds in range(12):
                #for a specific cardset, the start player keep same
                in_round_oindex = []
                #print("round: ", rounds)
                for player_seq in range(4): #4 players. it is sequence rather than S-E-N-W
                    oindexes_x = round_players_oindexes[:, player_seq, rounds]
                    fmt_x = round_players_trumps[:, player_seq, rounds]
                    result, in_round_oindex = self.test_step_play_1card_common2_anysenw(self.players[first_players - 1 + player_seq], 
                                                                                        fmt_x, oindexes_x, in_round_oindex=in_round_oindex)
                    results.append(result)
                    if False == result:
                        self.test_step_play_1card_common4_error()

            if 0 == i%100:
                print(".", end='')
            if 0 == i%1000:
                print(i, end='')
                
        return np.array(results).all()

    def test_step_play_1card_auto(self):
        #impossible to cover all combinations. (card deal=P54-54=54!)!!!
        return True

    def TEST_step_play_1card(self):
        ######################################
        # base DATA preparation
        # in env:
        #   self.n: 与game_envs.n一致
        #   self.players_cards[0]/[1]..[played]. overwrite
        #   self.render = False
        #   self.state3s[], it is output
        # in env.full_poker:
        #   self.full_poker.np_cards[played]. overwrite [self.n, ..]
        #   self.full_poker.np_cards[who]. overwrite [self.n, ..]
        #   self.full_poker.np_cards[discard]. overwrite [self.n, ..]
        #   self.full_poker.np_bankers
        #   self.full_poker.np_trumps
        #   self.full_poker.np_rounds
        # direct related methods:
        #   self.update_inhand_state3()
        #   self.update_played_state3()
        #   self.full_poker.render(). NO due to self.render = False
        # indirect related methods:
        #   self.full_poker.ones_cardset_strs(). NO due to self.render = False
        #   self.full_poker.get_player_cards_by_players(). NO due to self.render = False
        #   self.full_poker.build_player_string_per_card(). NO due to self.render = False
        # side tested method:
        #   self.init_all_player_cards()
        #   self.state3_reset()
        #   self.full_poker.set_trumps_banker()
        # side DATA changed:
        #   none
        results = []
        if self.n != self.game_envs.n:
            print("PokerEnvironment_6_1::step_play_1card(): PRE CHECK fail", ErrorIDs.ERR_N)
            return False, ErrorIDs.ERR_N

        self.assign_full_poker_np_trumps()
        self.assign_full_poker_np_bankers()  #only support 'all bankers are same' @shuffle_cards()
        self.assign_full_poker_np_rounds()
        
        self.shuffle_and_deal_cards() #need not sorting
        if PRE_CHECK:
            cardset_0 = self.full_poker.np_cards[0]
            cardset_n = self.full_poker.np_cards[self.n-1]
            c1 = (cardset_0 == cardset_n)
            verified_oindex = np.array([0,10,40,53])
            verified_who = np.array([dc.Players.SOUTH,dc.Players.NORTH,dc.Players.WEST,dc.Players.NORTH])
            c2 = (cardset_0[verified_oindex, dc.COL_WHO] == verified_who)
            verified_oindex = np.array([1,11,41,52])
            verified_who = np.array([dc.Players.WEST,dc.Players.EAST,dc.Players.NORTH,dc.Players.EAST])
            c3 = (cardset_n[verified_oindex, dc.COL_WHO] == verified_who)

        self.discard_cards()
        if PRE_CHECK:
            if self.n > 1:
                cardset_1 = self.full_poker.np_cards[1]
            else:
                cardset_1 = self.full_poker.np_cards[0]
            verified_oindex = np.array([16, 17, 35, 43, 45, 47])
            c4 = (cardset_1[verified_oindex, dc.COL_DISCARDED] == True)
        
        self.players_cards = self.init_all_player_cards()
        self.np_start_player_cards = self.players_cards[0]
        if PRE_CHECK:
            cardset_0 = self.np_start_player_cards[0]
            cardset_n = self.players_cards[1][self.n-1][2] #last cardset, West
            verified_oindex = np.array([16, 17, 35, 43, 45, 47])[:,np.newaxis]
            discard_samples = np.where(cardset_0[:,dc.COL_OINDEX] == verified_oindex)
            c4_2 = (cardset_0[discard_samples[1], dc.COL_DISCARDED] == True)
            c4_3 = (cardset_0[:, dc.COL_PLAYED] == False)
            verified_oindex = np.array([0,4,18,21,45,47])[:,np.newaxis]
            banker_samples = np.where(cardset_0[:,dc.COL_OINDEX] == verified_oindex)
            c5 = (len(banker_samples[1]) == len(verified_oindex))
            verified_oindex = np.array([1,20,32,40])[:,np.newaxis]
            player_samples = np.where(cardset_n[:,dc.COL_OINDEX] == verified_oindex)
            c6 = (len(player_samples[1]) == len(verified_oindex))
            verified_oindex = np.array([16, 17, 35, 43, 45, 47])[:,np.newaxis]
            discard_samples = np.where(cardset_n[:,dc.COL_OINDEX] == verified_oindex)
            c6_2 = (len(discard_samples[1]) == 0)
            c6_3 = (cardset_n[:, dc.COL_PLAYED] == False)
        
        fmt1, fmt2, fmt3 = self.net_input_format[1], self.net_input_format[2], self.net_input_format[3]
        self.state3_reset(fmt2, fmt3)
        #shape(n, 4, 5, 54): S is the 1st of dim[4], who si the banker to discard
        self.state3s[:,0,0,np.s_[16, 17, 35, 43, 45, 47]] = fmt1
        if PRE_CHECK:
            cardset_0 = self.state3s[0] #cardset=0, shape=(4,5,54)
            cardset_n = self.state3s[self.n-1]
            verified_player = dc.Players.SOUTH
            verified_oindex = np.array([0, 14, 21, 26])
            expected_state3 = [fmt3, fmt3, fmt2, fmt2]
            c7 = (expected_state3 == cardset_0[verified_player-1, 0, verified_oindex])
            verified_player = dc.Players.WEST
            verified_oindex = np.array([1, 5, 34, 48])
            expected_state3 = [fmt3, fmt3, fmt2, fmt2]
            c8 = (expected_state3 == cardset_0[verified_player-1, 0, verified_oindex])
            verified_player = dc.Players.NORTH
            verified_oindex = np.array([6, 53, 25, 50])
            expected_state3 = [fmt3, fmt3, fmt2, fmt2]
            c9 = (expected_state3 == cardset_n[verified_player-1, 0, verified_oindex])
            verified_player = dc.Players.EAST
            verified_oindex = np.array([2, 52, 44, 46])
            expected_state3 = [fmt3, fmt3, fmt2, fmt2]
            c10 = (expected_state3 == cardset_n[verified_player-1, 0, verified_oindex])

            c11 = cardset_0[dc.Players.EAST-1, 1:5].any()
            c12 = cardset_0[dc.Players.NORTH-1, 1:5].any()
            c13 = cardset_n[dc.Players.WEST-1, 1:5].any()
            c14 = cardset_n[dc.Players.SOUTH-1, 1:5].any()
        
            discard_oindex = np.array([16, 17, 35, 43, 45, 47])
            c15 = (cardset_0[0,0,discard_oindex] == fmt1)
            c16 = (cardset_n[0,0,discard_oindex] == fmt1)
        if PRE_CHECK:
            c = (c1.all() and c2.all() and c3.all() and c4.all() and c4_2.all() and c4_3.all() and c5 and 
                 c6 and c6_2 and c6_3.all() and c7.all() and c8.all() and c9.all() and c10.all() and 
                 not c11 and not c12 and not c13 and not c14 and c15.all() and
                 c16.all())
            if False == c:
                print("PokerEnvironment_6_1::step_play_1card(): PRE CHECK fail", ErrorIDs.ERR_MISC)
                return False, ErrorIDs.ERR_MISC
        
        
        self.render = False #True
        
        ######################################
        # base INPUT: (inside xxx_0/1/2/3()...)
        #   players_x
        #   fmt_x
        #   oindexes_x, 
        #   in_round_oindex=[],
        # assume len=10
        
        ######################################
        # run sub testcase:
        results.append(self.test_step_play_1card_0())
        results.append(self.test_step_play_1card_1()) #x_0() follows x_1(), need not init DATA inside
        results.append(self.test_step_play_1card_2())
        results.append(self.test_step_play_1card_3())
        
        if self.test_auto_level > 0:
            results.append(self.test_step_play_1card_massive())
            print("\n")
            if self.test_auto_level > 1 :
                results.append(self.test_step_play_1card_auto())
                print("\n")
        
        result = np.array(results).all()
        print("PokerEnvironment_6_1::step_play_1card(): ", result, results)
        return results 

    
    def test_round_result_0(self, round_played_cards):
        round_winners, scores_got = self.round_result(round_played_cards)
        #print(round_winners, scores_got)
        result_winner = (round_winners==dc.Players.EAST)
        result_score = (scores_got==0)
        return result_winner.all() and result_score.all()
    
    def test_round_result_1(self, round_played_cards): #variant1, change the DATA or INPUT as needed
        expected_result = []
        round_played_cards[0] = [[dc.Players.SOUTH, 0], [dc.Players.EAST,  2], [dc.Players.NORTH, 3], [dc.Players.WEST,  4]]
        expected_result.append([dc.Players.SOUTH, 5])

        round_played_cards[1] = [[dc.Players.SOUTH, 15], [dc.Players.EAST,  25], [dc.Players.NORTH, 17], [dc.Players.WEST,  22]]
        expected_result.append([dc.Players.EAST, 25])

        round_played_cards[2] = [[dc.Players.SOUTH, 28], [dc.Players.EAST,  29], [dc.Players.NORTH, 30], [dc.Players.WEST,  1]]
        expected_result.append([dc.Players.WEST, 5])

        round_played_cards[3] = [[dc.Players.SOUTH, 48], [dc.Players.EAST,  40], [dc.Players.NORTH, 43], [dc.Players.WEST,  3]]
        expected_result.append([dc.Players.EAST, 15])
        
        round_played_cards[4] = [[dc.Players.SOUTH, 40], [dc.Players.EAST,  27], [dc.Players.NORTH, 14], [dc.Players.WEST,  9]]
        expected_result.append([dc.Players.SOUTH, 10]) #D2, C2, H2, S10

        round_played_cards[5] = [[dc.Players.SOUTH, 4], [dc.Players.EAST,  9], [dc.Players.NORTH, 14], [dc.Players.WEST,  52]]
        expected_result.append([dc.Players.WEST, 15])

        round_played_cards[6] = [[dc.Players.SOUTH, 9], [dc.Players.EAST,  4], [dc.Players.NORTH, 0], [dc.Players.WEST,  52]]
        expected_result.append([dc.Players.WEST, 15])

        round_played_cards[7] = [[dc.Players.SOUTH, 23], [dc.Players.EAST,  22], [dc.Players.NORTH, 25], [dc.Players.WEST,  38]]
        expected_result.append([dc.Players.NORTH, 30])

        round_played_cards[8] = [[dc.Players.SOUTH, 13], [dc.Players.EAST,  18], [dc.Players.NORTH, 16], [dc.Players.WEST,  21]]
        expected_result.append([dc.Players.SOUTH, 0])

        round_played_cards[9] = [[dc.Players.SOUTH, 9], [dc.Players.EAST,  0], [dc.Players.NORTH, 6], [dc.Players.WEST,  3]]
        expected_result.append([dc.Players.EAST, 10])

        round_winners, scores_got = self.round_result(round_played_cards)
        #print(round_winners, scores_got)
        np_expected_result = np.array(expected_result)
        result_winner = (round_winners==np_expected_result[:,0])
        result_score = (scores_got==np_expected_result[:,1])
        return result_winner.all() and result_score.all()

    def test_round_result_2(self, round_played_cards):
        expected_result = []
        round_played_cards[0] = [[dc.Players.EAST,  1], [dc.Players.NORTH, 15], [dc.Players.WEST,  0], [dc.Players.SOUTH, 14]]
        expected_result.append([dc.Players.EAST, 0])

        round_played_cards[1] = [[dc.Players.NORTH, 15], [dc.Players.WEST,  27], [dc.Players.SOUTH, 14], [dc.Players.EAST,  1]]
        expected_result.append([dc.Players.EAST, 0])

        round_played_cards[2] = [[dc.Players.WEST,  17], [dc.Players.SOUTH, 14], [dc.Players.EAST,  1], [dc.Players.NORTH, 40]]
        expected_result.append([dc.Players.EAST, 5])

        round_played_cards[3] = [[dc.Players.SOUTH, 48], [dc.Players.EAST,  14], [dc.Players.NORTH, 40], [dc.Players.WEST,  1]]
        expected_result.append([dc.Players.WEST, 10])
        
        round_played_cards[4] = [[dc.Players.EAST,  43], [dc.Players.NORTH, 15], [dc.Players.WEST,  45], [dc.Players.SOUTH, 22]]
        expected_result.append([dc.Players.WEST, 15])

        round_played_cards[5] = [[dc.Players.NORTH, 35], [dc.Players.WEST,  33], [dc.Players.SOUTH, 40], [dc.Players.EAST,  14]]
        expected_result.append([dc.Players.SOUTH, 10])

        round_played_cards[6] = [[dc.Players.WEST,  33], [dc.Players.SOUTH, 40], [dc.Players.EAST,  35], [dc.Players.NORTH, 14]]
        expected_result.append([dc.Players.SOUTH, 10])

        round_played_cards[7] = [[dc.Players.SOUTH, 23], [dc.Players.EAST,  2], [dc.Players.NORTH, 0], [dc.Players.WEST,  12]]
        expected_result.append([dc.Players.NORTH, 10])

        round_played_cards[8] = [[dc.Players.EAST,  0], [dc.Players.NORTH, 2], [dc.Players.WEST,  14], [dc.Players.SOUTH, 28]]
        expected_result.append([dc.Players.WEST, 0])

        round_played_cards[9] = [[dc.Players.NORTH, 14], [dc.Players.WEST,  3], [dc.Players.SOUTH, 10], [dc.Players.EAST,  0]]
        expected_result.append([dc.Players.NORTH, 0])

        round_winners, scores_got = self.round_result(round_played_cards)
        #print(round_winners, scores_got)
        np_expected_result = np.array(expected_result)
        result_winner = (round_winners==np_expected_result[:,0])
        result_score = (scores_got==np_expected_result[:,1])
        return result_winner.all() and result_score.all()
    
    def test_round_result_common_1_create_class_oindex(self, trump_suit, card_round, all_oindexes):
        #have to use the target code since np_cards[trump]=true is needed
        self.full_poker.set_trumps_banker(np.array([trump_suit]*self.n), np.array([card_round]*self.n), np.array([dc.Players.SOUTH]*self.n))
        #aviod the target code.
        #self.assign_full_poker_np_trumps(trump_suit)  #S=trump suit
        #self.assign_full_poker_np_rounds(card_round)  #round=2        
        self.assign_total_weights(trump_suit, card_round)
        
        all_oindexes_2 = np.delete(all_oindexes, card_round-1, axis=1) #remove '2' from 'suit'
        class_oindex = []
        class_oindex.append(all_oindexes_2[0])   #0-3: 0
        class_oindex.append(all_oindexes_2[1])   #4-7: 1
        class_oindex.append(all_oindexes_2[2])   #8-11: 2
        class_oindex.append(all_oindexes_2[3])   #12-15: 3
        class_oindex.append(all_oindexes[:3, card_round-1]) #16-18: 4
        class_oindex.append([all_oindexes[3, card_round-1]])  #19: 5
        class_oindex.append([52])  #20: 6
        class_oindex.append([53])  #21: 7
        return class_oindex
        

    def test_round_result_common_2(self, one_two_three_four, class_oindex, round_played_cards, g_cont, l_cont):
        class_oindex_2 = copy.deepcopy(class_oindex)
        selected_oindexes = []
        result = True
        #select oindex from each class
        for class_1 in one_two_three_four:
            if class_1 <= 15 :
                selected_class = int(class_1/4)
            elif class_1 <= 18:
                selected_class = 4
            else:
                selected_class = class_1-14

            selected_oindex = np.random.choice(class_oindex_2[selected_class], size=(1), replace=False)
            selected_oindexes.append(selected_oindex[0])
            to_remove_index = np.where(class_oindex_2[selected_class] == selected_oindex)
            class_oindex_2[selected_class] = np.delete(class_oindex_2[selected_class], to_remove_index[0])

        #run  'round_result()'            
        round_played_cards.append([[dc.Players.SOUTH, selected_oindexes[0]], [dc.Players.EAST, selected_oindexes[1]], [dc.Players.NORTH, selected_oindexes[2]], [dc.Players.WEST, selected_oindexes[3]]])
        g_cont += 1
        l_cont += 1
        
        if g_cont % self.n == 0 and g_cont > 0:
            expected_result = []
            for i in range(self.n):
                round_winner, score_got = self.round_result0(i, round_played_cards[i])
                expected_result.append([round_winner, score_got])

            round_winners, scores_got = self.round_result(round_played_cards)
            np_expected_result = np.array(expected_result)
            c1 = (round_winners == np_expected_result[:,0])
            c2 = (scores_got == np_expected_result[:,1])
            result = c1.all() and c2.all()
            if result:
                pass
            else:
                print("mismatch: ", g_cont, selected_oindexes,one_two_three_four)
                print("mismatch: ", expected_result)
                print("mismatch: ", round_winners, scores_got)

            round_played_cards = []
            l_cont = 0
        
        if g_cont % 1000 == 0:
            print(".", end='')
        if g_cont % 10000 == 0:
            print(g_cont, end='')
        #print(g_cont, trump_suit, card_round, selected_oindexes,[one, two, three, four])
        return result, selected_oindexes, round_played_cards, g_cont, l_cont

    def test_round_result_common_3_error(self):
        print("round_result error. TBD")
        
    def test_round_result_auto(self, round_played_cards):
        #DATA: global data, local data, member variable
        #INPUT: from function entry
        #OPERATION: how to define? standard code rule? loop/if/else/+/-/*//=/invoking/, should be a subset of programming language
        #PATH: program execution path
        ######################################
        # base DATA variants
        # in env:
        #   self.n: need not
        #   self.total_weights: yes=13*4, depends on round and trump
        # in env.full_poker:
        #   self.full_poker.np_cards[score]. not
        #   self.full_poker.np_cards[trump], used in round_result0()
        #   self.full_poker.np_rounds: yes=13
        #   self.full_poker.np_trumps: yes=4
        # direct related methods:
        #   self.dynamic_card_weights()
        # indirect related methods:
        #   self.round_result0(): as cross checking method
        #
        ######################################
        # base INPUT:
        #   round_played_cards: yes=
        #for 出牌大小的比较 in a round
        # 0: basis:         1 -13 *3, static
        # 2: suit trump:    27-39 *1, static
        # 3: nomral 2:      40    *3, statis
        # 5: master 2:      42    *1, static
        # 6: BJ:            43    *1, statis
        # 7: RJ:            44    *1, statis
        ######################################
       
        #(0-3)/(4-7)/(8-11): 3 non-trump suits each repeat 4
        #(12-15): 1 trump suit, repeat 4
        #16,17,18, normal2, 3 cards
        #19, master 2
        #20, BJ
        #21, RJ
        total_class = 22
        np_candidate_classes = np.arange(total_class)

        g_cont = 0
        l_cont = 0
        round_played_cards = []
        result = True
        
        suits_template = [dc.CardSuits.SPADES, dc.CardSuits.HEARTS, dc.CardSuits.CLUBS, dc.CardSuits.DIAMONDS]
        oindex_template0 = dc.cards_T[:52, dc.COL_OINDEX].reshape(4, 13)
        
        for trump_suit in suits_template:
            oindex_template = copy.deepcopy(oindex_template0)
            all_oindexes = np.delete(oindex_template, trump_suit-1, axis=0)
            all_oindexes = np.concatenate((all_oindexes, oindex_template[trump_suit-1][np.newaxis,:]), axis=0)    #0-2: non; 3:trump
            
            for card_round in range(1,14,1):
                self.assign_full_poker_np_cards()
                class_oindex = self.test_round_result_common_1_create_class_oindex(trump_suit, card_round, all_oindexes)
                
                p22_4 = list(itertools.permutations(np_candidate_classes, 4))
                for one_two_three_four in p22_4:
                    #round_played_cards, g_cont, l_cont are updated inside common_2(). but can not be retrieved back. has to 'return' explicity
                    result0, _, round_played_cards, g_cont, l_cont = self.test_round_result_common_2(one_two_three_four, class_oindex, round_played_cards, g_cont, l_cont)
                    result = result and result0 
                    if False == result0:
                        self.test_round_result_common_3_error()
        return result
    
    def test_round_result_massive(self, round_played_cards, limit=100000):
        # same rule to 'auto'
        
        total_class = 22
        np_candidate_classes = np.arange(total_class)
        np.random.shuffle(np_candidate_classes)

        g_cont = 0
        l_cont = 0
        round_played_cards = []
        result = True
        
        oindex_template0 = dc.cards_T[:52, dc.COL_OINDEX].reshape(4, 13)
        suits_template = [dc.CardSuits.SPADES, dc.CardSuits.HEARTS, dc.CardSuits.CLUBS, dc.CardSuits.DIAMONDS]

        for i in range(limit):
            if 0 == l_cont: #cycle algin to self.n
                selected_trump_suit = np.random.choice(suits_template)
                selected_trump_round = np.random.choice(13)+1
                self.assign_full_poker_np_cards()
    
                oindex_template = copy.deepcopy(oindex_template0)
                all_oindexes = np.delete(oindex_template, selected_trump_suit-1, axis=0)
                all_oindexes = np.concatenate((all_oindexes, oindex_template[selected_trump_suit-1][np.newaxis,:]), axis=0)    #0-2: non; 3:trump
                class_oindex = self.test_round_result_common_1_create_class_oindex(selected_trump_suit, selected_trump_round, all_oindexes)

            one_two_three_four = np.random.choice(np_candidate_classes, size=(4), replace=False)
            result0, _, round_played_cards, g_cont, l_cont = self.test_round_result_common_2(one_two_three_four, class_oindex, round_played_cards, g_cont, l_cont)
            result = result and result0
            if False == result0:
                self.test_round_result_common_3_error()
        return result
            

    
    def TEST_round_result(self):
        ######################################
        # base DATA preparation
        # in env:
        #   self.n: 与game_envs.n一致
        #   self.total_weights
        # in env.full_poker:
        #   self.full_poker.np_cards[score]. NEED NOT. may need not since the 'score' was assigned in poker init()
        #   self.full_poker.np_cards[trump], used in round_result0()
        #   self.full_poker.np_rounds
        #   self.full_poker.np_trumps
        # direct related methods:
        #   self.dynamic_card_weights()
        # indirect related methods:
        #   none
        # side tested method:
        #   self.env.poker.set_trumps_banker()
        #   self.dynamic_card_weights()
        #   self.static_card_weights(), partially:all trump suit and round are same in each cardset
        # side DATA changed:
        #   self.np_cards[:,:,COL_SUIT]
        #   self.np_cards[:,:,COL_NAME]
        #   self.np_cards[:,:,COL_TRUMP]

        results = []
        if self.n != self.game_envs.n:
            return False, ErrorIDs.ERR_N
        
        self.assign_full_poker_np_cards()
        self.assign_full_poker_np_trumps()  #S=trump suit
        self.assign_full_poker_np_rounds()  #round=2
        self.assign_total_weights()
        
        
        ######################################
        # base INPUT:
        #   round_played_cards, list = self.n * [ [player1, oindex1], [player2, oindex2], ... ]
        
        round_played_cards = []
        for i in range(self.n):
            round_played_card = []
            round_played_card.append([dc.Players.SOUTH, 0]) #S-A
            round_played_card.append([dc.Players.EAST,  1]) #S-2, master trump
            round_played_card.append([dc.Players.NORTH, 2]) #S-3
            round_played_card.append([dc.Players.WEST,  3]) #S-4
            round_played_cards.append(round_played_card)
        
        
        ######################################
        # run sub testcase:
        results.append(self.test_round_result_0(round_played_cards)) #data is not variant
        results.append(self.test_round_result_1(round_played_cards))
        results.append(self.test_round_result_2(round_played_cards))
        if self.test_auto_level > 0 :
            results.append(self.test_round_result_massive(round_played_cards))
            print("\n")
            if self.test_auto_level > 1:
                results.append(self.test_round_result_auto(round_played_cards))
                print("\n")
                
        result = np.array(results).all()
        print("PokerEnvironment_6_1::round_result(): ", result, results)
        return results 

    def test_game_rewards_0(self, game_winners, game_rewards, level_raised):
        game_rewards0 = copy.deepcopy(game_rewards)
        game_rewards = self.game_rewards(game_winners, game_rewards, level_raised)
            
        fmt3_2 = self.play_reward_template[3] * (level_raised + 1)  #winner addition
        fmt0_2 = self.play_reward_template[0] * fmt3_2  #losser addition, 0 or neg
        
        for batch_id, winners in enumerate(game_winners):
            for player in [dc.Players.SOUTH, dc.Players.EAST, dc.Players.NORTH, dc.Players.WEST]:
                if player in winners:
                    game_rewards0[player][:, batch_id] += fmt3_2[batch_id]
                else:
                    game_rewards0[player][:, batch_id] += fmt0_2[batch_id]
                
        c1 = game_rewards0[dc.Players.SOUTH] == game_rewards[dc.Players.SOUTH]
        c2 = game_rewards0[dc.Players.EAST] == game_rewards[dc.Players.EAST]
        c3 = game_rewards0[dc.Players.NORTH] == game_rewards[dc.Players.NORTH]
        c4 = game_rewards0[dc.Players.WEST] == game_rewards[dc.Players.WEST]
        
        c = c1.all() and c2.all() and c3.all() and c4.all()
        return c
    
    
    def TEST_game_rewards(self):
        ######################################
        # base DATA preparation: 
        #   env.play_reward_template[], read from game.env from config
        #   meas object: it is default ready in env_xx.py. need not allocate new one
        ######################################
        self.play_reward_template = self.game_envs.play_reward_template
        #print(self.play_reward_template)

        ######################################
        # base INPUT preparation: 
        #   NOTE: cardsets == self.n
        game_winners = np.array([[dc.Players.SOUTH,  dc.Players.NORTH], 
                                 [dc.Players.NORTH,  dc.Players.SOUTH],
                                 [dc.Players.NORTH,  dc.Players.SOUTH],
                                 [dc.Players.EAST,   dc.Players.WEST], 
                                 [dc.Players.WEST,   dc.Players.EAST]])  #batch n = 5

        game_rewards = {dc.Players.SOUTH: np.full((11, game_winners.shape[0],),  0.1),
                        dc.Players.EAST:  np.full((11, game_winners.shape[0],), -0.2),
                        dc.Players.NORTH: np.full((11, game_winners.shape[0],),  0.1),
                        dc.Players.WEST:  np.full((11, game_winners.shape[0],), -0.2)}  #must S=N, E=W
        
        level_raised = np.array([1, 2, 0, 3, 1])

        results = []
        # run sub testcase:
        results.append(self.test_game_rewards_0(game_winners, game_rewards, level_raised))
        #static case is enought to cover all checkpoints!        
                
        result = np.array(results).all()
        print("PokerEnvironment_6_1::game_rewards() ", result, results)


class Game54_Offline_Verify:
    def __init__(self, games, test_auto_level, class_short_name):
        self.games = games   #would be standalone data object or running data
        #refer to objects in game
        self.batch_size = games.batch_size
        self.envs = games.card_envs
        self.pokers = games.card_envs.full_poker
        self.play_agents = games.play_agent
        self.discard_agent = games.discard_agent
        self.test_auto_level = test_auto_level
        
        #local objects
        self.poker_ut = FullPokers_UT(self.pokers)
        self.env_ut = PokerEnvironment_6_1_UT(self.envs, self.test_auto_level)
        self.proxy_ut = PlayAgentProxy_UT(self.play_agents, self.envs, self.batch_size, self.test_auto_level)
        self.game_ut = Game_UT(class_short_name)
        self.guess_cnn_ut = PlayGuess_CNN_UT(self.batch_size)
        
        #clear all online checkings. to prevent nested checking
        game_verify_on.checkpoints.allow_checkpoints = []
        return

    def run_all_cases(self, sanity_args={}):
        ydl1 = self.proxy_ut
        ydl2 = self.env_ut
        ydl3 = self.poker_ut
        #ydl2.TEST_collect_card_last_round()


        if 3 == self.test_auto_level:
            '''
            ##############
            # sanity all agents
            # 20220627: move to game_x_x:UT()
            start_p_set = sanity_args['start_p_set']
            selected_p_set3 =  sanity_args['selected_p_set3']
            game_config = sanity_args['game_config']
            init_training = sanity_args['init_training']
            id_game_id = sanity_args['id_game_id']
            render_in_train = sanity_args['render_in_train']
            
            selected_p_set = range(start_p_set, selected_p_set3+1)   #selected_p_set3 is the last p_set. [810, selected_p_set3]
            for i, params in enumerate(game_config):
                if params[id_game_id] in selected_p_set:  #id
                    selected_p_set2 = i
                    seed = 13
                    reload = False
                    init_training(reload, seed, render_in_train, selected_p_set2, save_agent=False) #don't save agnet .h5
            '''
            print("UT:offline: do nothing in auto=3")
            return        


        objs_list = dir(self.guess_cnn_ut)  #can't see the data object in parent class. but method is seen
        for obj_name in objs_list:
            if 0 == obj_name.find("TEST_"):
                test_method = getattr(self.guess_cnn_ut, obj_name)
                print("GUESS CNN: ", obj_name)
                test_method()

        objs_list = dir(self.game_ut)  #can't see the data object in parent class. but method is seen
        for obj_name in objs_list:
            if 0 == obj_name.find("TEST_"):
                test_method = getattr(self.game_ut, obj_name)
                print("GAME: ", obj_name)
                test_method()

        objs_list = dir(self.proxy_ut)  #can't see the data object in parent class. but method is seen
        for obj_name in objs_list:
            if 0 == obj_name.find("TEST_"):
                test_method = getattr(self.proxy_ut, obj_name)
                print("PROXY: ", obj_name)
                test_method()

        objs_list = dir(self.env_ut)  #can't see the data object in parent class. but method is seen
        for obj_name in objs_list:
            if 0 == obj_name.find("TEST_"):
                test_method = getattr(self.env_ut, obj_name)
                print("ENV: ", obj_name)
                test_method()
        
        objs_list = dir(self.poker_ut)  #can't see the data object in parent class. but method is seen
        for obj_name in objs_list:
            if 0 == obj_name.find("TEST_"):
                test_method = getattr(self.poker_ut, obj_name)
                print("POKER: ", obj_name)
                test_method()

        return []

